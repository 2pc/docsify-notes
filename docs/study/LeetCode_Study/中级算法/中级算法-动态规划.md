# 中级算法

> 题库链接：https://leetcode-cn.com/explore/interview/card/top-interview-questions-medium/

* 动态规划

  1.  跳跃游戏

   + 语言：java

   + 思路：从题目看来，需要能够回退，感觉可以递归回溯。后面感觉，可以数组从尾向头看，每个位置记录能到达的最靠尾部的位置，最后起点能不能到终点。从最后往前推算，找到第一个能够到达终点的倒数某个点，从此点到起点。

   + 代码（1ms，41.33MB）：

     ```java
     class Solution {
         public boolean canJump(int[] nums) {
             int res = nums.length-1; // 最接近起点，同时又能够到达终点的点的下标。
             for(int i = nums.length-2;i>0;--i){
                 if(nums[i]==0)
                     continue;
                 if(i>0&&nums[i] + i >= res)
                     res = i;
             }
             return nums[0]>=res;
         }
     }
     ```
     
   + 参考代码1(0ms)：没想到这个递归方式的反而更快

     ```
   class Solution {
         public boolean canJump(int[] nums) {
           return backTrace(nums,nums.length-1);
         }
   
         private static boolean backTrace(int[] nums,int idx){
             int zero = -1;
             for (int i=idx-1;i>=0;i--){
                 if (nums[i]==0){
                     zero = i;
                     break;
                 }
             }
             if (zero==-1||(nums.length==1)){
                 return true;
             }
             boolean flag = false;
             for (int i = 0;i<zero;i++){
                 if (nums[i]>zero-i){
                     flag = flag || backTrace(nums,i);
                 }
           }
             return flag;
       }
     }
     ```
  + 参考代码2（1ms）：和我的思路可以说没有啥区别。就是最后停止的位置不大一样而已。
  
    ```java
    class Solution {
        public boolean canJump(int[] nums) {
            int last = nums.length - 1;
            for (int i = nums.length - 1; i >= 0; i--){
                if (i + nums[i] >= last) {
                    last = i;
                }
            }
            return last == 0;
        }
  }
    ```
  
  2. 不同路径
  
  + 语言：java
  
  + 思路：咋一看比前面那些啥的简单多了，就写了9行（递归）。结果运行就超时，哈哈。用本地编译器看了下m=51，n=9的情况，运行将近17s，恐怖如斯，哈哈。画图后，可以得知和斐波那契数列类似操作。据然超时，那就用非递归的写法好了(结果这个非递归的0ms，额。前面题目动不动就递归的，惯性思维了)。
  
  + 代码（0ms，36.7MB）：
  
    ```java
    class Solution{
        public int uniquePaths(int m, int n) {
            int[][] map = new int[n][m];
            for(int i =0;i<n;++i){
                for(int j =0;j<m;++j){
                    if(i==0||j==0)
                        map[i][j]=1;
                    else
                        map[i][j]=map[i-1][j]+map[i][j-1];
                }
            }
            return map[n-1][m-1];
        }
    }
    ```
  
  + 参考代码（0ms）：有点骚，只用一维数组。不过本身最终问题都是化为只有一行去考虑的，所以好像没啥毛病，只要最后都经过双层for循环就ok了。原本画图的上一行/下一行即数组原本的值，而右侧/左侧用于斐波那契相加的则同一行的右侧/左侧。
  
    ```java
    class Solution {
        public int uniquePaths(int m, int n) {
          int[] cur=new int[n];
          Arrays.fill(cur,1);
          for(int i=1;i<m;i++){
              for(int j=1;j<n;j++){
                  cur[j]=cur[j]+cur[j-1];
              }
          }
    
          return cur[n-1];
        }
    }
    ```
  
  


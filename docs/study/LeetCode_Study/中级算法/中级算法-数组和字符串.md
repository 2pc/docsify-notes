# 中级算法

> 题库链接：https://leetcode-cn.com/explore/interview/card/top-interview-questions-medium/

* 数组和字符串

  1. 三数之和

   + 语言:java

   + 思路：只想到用多层for嵌套的解答方式，但是感觉会超时。

   + 参考代码1(47ms)：先排序，然后用3个指针，头尾指针，然后还有一个是头指针下一个，两边往中间移动，然后寻找3值和为0；(说出来可能不信，我有想到过和这个差不多的，我以为这样也是会超时的)

     > https://blog.csdn.net/qq_35170267/article/details/81031368
     
     ```java
class Solution {
         public List<List<Integer>> threeSum(int[] nums) {
             List<List<Integer>> result = new ArrayList<>();
             Arrays.sort(nums);
             for (int i = 0; i < nums.length; i++) {
                 if (nums[i] > 0) break;
                 if (i > 0 && nums[i] == nums[i - 1]) continue;
                 int j = nums.length - 1;
                 int target = 0 - nums[i];
                 int k = i + 1;
                 while (k < j) {
                     if (nums[k] + nums[j] == target) {
                         List<Integer> item = Arrays.asList(nums[i], nums[k], nums[j]);
                         result.add(item);
                         while (k < j && nums[k] == nums[k + 1]) k++;
                         while (k < j && nums[j] == nums[j - 1]) j--;
                         k++;j--;
                     } else if (nums[k] + nums[j] < target) {
                         k++;
                     } else {
                         j--;
                     }
                 }
             }
             return result;
         }
     }
     ```
   
   + 参考代码2(20ms):其实和参考代码1没有本质区别，不过写法不太一样而已
   
     ```java
     class Solution {
         List<List<Integer>> res = new ArrayList<List<Integer>>();
         public List<List<Integer>> threeSum(int[] nums) {
             int len = nums.length;
             Arrays.sort(nums);
             
             if(nums == null && len <= 2)
                 return res;
             
             for(int i = 0; i<len; i++){
                 if(i != 0 && nums[i-1] == nums[i])
                     continue;
                 find(nums, i+1, len-1, nums[i]);
             }
             return res;
         }
         
         public void find(int[]nums, int left, int right, int target){
             while(left < right){
                 if(target + nums[left] + nums[right] == 0){
                     List<Integer> list = new ArrayList<Integer>();
                     list.add(target);
                     list.add(nums[left]);
                     list.add(nums[right]);
                     res.add(list);
                     while(left < right && nums[left] == nums[left+1])
                         left++;
                     while(left < right && nums[right] == nums[right-1])
                         right--;
                     left++;
                     right--;
                 }
                 else if(nums[left] + nums[right] + target < 0)
                     left++;
                 else
                     right--;
             }
         }
     }
     ```
   
   + 参考代码3(14ms):这个太过复杂了，虽然速度是比较快
   
     ```java
     class Solution {
         // 解题思路：
         // 一、计算当前数组最大、最小值；以及正数、负数、0各自的总数
         // 二、0的个数要是大于等于3，将{0，0，0}存入；若正数或者负数的个数为0，直接返回结果
         // 三、当前数组的最大、最小值更新：
         // 最大值 最多为 两倍最小值的相反数（max = -min * 2）
         // 最小值 最多为 两倍最大值的相反数（min = -max * 2）
         // 四、计算出每个数出现的次数，存入临时数组中，并将负数、正数存到各自的数组，做升序排序
         // 五、结果分三种情况
         // 两个一样的正数，一个负数
         // 两个一样的负数，一个正数
         // 三个不同的数
         // 六、从负数的数组从后开始遍历（nv）；正数的数组从大于等于 负数 的 相反数 的 中位数开始遍历（pv = -nv / 2）；第三个数 cv  = 0 - nv - pv 在 [nv, pv] 的区间中寻找，避免重复添加；把符合条件的数组添加到结果中。
         public List<List<Integer>> threeSum(int[] nums) {
             if (nums.length < 3) return Collections.emptyList(); 
             List<List<Integer>> res = new ArrayList<>(); 
             int minValue = Integer.MAX_VALUE; 
             int maxValue = Integer.MIN_VALUE; 
             int negSize = 0, posSize = 0; 
             int zeroSize = 0; 
             for (int v : nums) { 
                 if (v < minValue) minValue = v; 
                 if (v > maxValue) maxValue = v; 
                 if (v > 0) posSize++; 
                 else if (v < 0) negSize++; 
                 else zeroSize++; 
             }
             if (zeroSize >= 3) res.add(Arrays.asList(0, 0, 0));//输出 三个 0 的情况 
             if (negSize == 0 || posSize == 0) return res;
             //此时minValue一定为负数，maxValue一定为正数
             //如果maxValue > -2*minValue，那么大于 -2*minValue的元素肯定不会是答案，可以排除掉，所以更新maxValue
             if (minValue * 2 + maxValue > 0) maxValue = -minValue * 2; 
             //同理更新minValue
             else if (maxValue * 2 + minValue < 0) minValue = -maxValue * 2;
             //自己构建一个hashmap，值表示元素重复次数，注意java数组默认值为 0
             int[] map = new int[maxValue - minValue + 1];
             int[] negs = new int[negSize];
             int[] poses = new int[posSize];
             negSize = 0;
             posSize = 0;
             for (int v : nums) {
                 if (v >= minValue && v <= maxValue) {//只保留在[minValue,maxValue]区间内的元素
                     if (map[v - minValue]++ == 0) {//计数加去重
                         if (v > 0) poses[posSize++] = v;//poses数组存所有去重后的正值
                         else if (v < 0) negs[negSize++] = v;//negs数组存所有去重后的负值 
                     }
                 }
             }
             //正负数两数组排序
             Arrays.sort(poses, 0, posSize);
             Arrays.sort(negs, 0, negSize);
             int basej = 0;
             for (int i = negSize - 1; i >= 0; i--) {//负数数组从后往前遍历
                 int nv = negs[i];//nv为当前负数值
                 //minp = -nv/2，相当于三元组中另外两元素的平均值，即为另两个元素中较小值的上界，较大值的下界
                 int minp = (-nv) >>> 1;
                 //定位到正数数组中值刚好小于平均值的元素（这个地方应该还可以优化为使用二分查找）
                 while (basej < posSize && poses[basej] < minp) basej++;
                 for (int j = basej; j < posSize; j++) {//正数数组从大于等于平均值的元素开始遍历
                     int pv = poses[j];//pv 为当前正数值
                     int cv = 0 - nv - pv;//cv 为要寻找的另一个值
                     //目标值 cv 应该在 [nv,pv] 当中
                     //如果不限制cv<=pv，当nv为奇数时，有可能会重复输出
                     if (cv >= nv && cv <= pv) {
                         if (cv == nv) {
                             if (map[nv - minValue] > 1)//两个相同的负数和一个正数的情况
                                 res.add(Arrays.asList(nv, nv, pv));
                         } else if (cv == pv) {
                             if (map[pv - minValue] > 1)//两个相同的正数和一个负数的情况
                                 res.add(Arrays.asList(nv, pv, pv));
                         } else {
                             if (map[cv - minValue] > 0)//三个不同元素的情况
                                 res.add(Arrays.asList(nv, cv, pv));
                         }
                     } else if (cv < nv) break;//如果 cv 小于 nv了，表明这种情况会在后面寻找，为避免重复输出，跳出循环
                 }
             }
             return res;
         }
     }
     ```
   
   + 参考2后重写(34ms):参考1后重写的代码基本和参考1差不多，但是一直超时，就算了。h后面知道自己之前大概哪里超时了，就是遇到相同元素前后指针往中间靠拢的时候漏+1or-1了
   
     ```java
     class Solution {
         List<List<Integer>> res = new ArrayList();
         public List<List<Integer>> threeSum(int[] nums) {
             int len = nums.length;
             if(len<2)
                 return res;
             Arrays.sort(nums);
             for(int i = 0 ; i < len && nums[i] <= 0; ++i){
                 if(i > 0 && nums[i] == nums[i-1])
                     continue;//跳过重复的数字
                 three(nums,nums[i],i+1,len-1);
             }
             return res;
         }
         
         public void three(int[] nums, int tmp, int head, int tail){
             while(head < tail){
                 if(tmp+nums[head]+nums[tail]==0){
                     List<Integer> mem = new ArrayList();
                     mem.add(tmp);
                     mem.add(nums[head]);
                     mem.add(nums[tail]);
                     res.add(mem);
                     while(head < tail && nums[head] == nums[head+1])
                         ++head;
                     while(head < tail && nums[tail] == nums[tail-1])
                         --tail;
                     ++head;
                     --tail;
                 }else if(tmp+nums[head]+nums[tail] < 0){
                     ++head;
                 }else{
                     --tail;
                 }
             }
         }
     }
     ```

  2. 矩阵置零

   + 语言：java

   + 思路：

   + 代码：

     ```java
     
     ```

     


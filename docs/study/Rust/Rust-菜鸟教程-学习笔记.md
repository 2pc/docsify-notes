# Rust-菜鸟教程-学习笔记

> [Rust 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/rust/rust-tutorial.html)

# 1. 概述

**语言特点**：

+ **高性能** - Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。
+ **可靠性** - Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。
+ **生产力** - Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具 —— 包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。

## 1.1 Cargo

Cargo 是 Rust 的构建系统和包管理器。

```shell
cargo build # 构建（build）工程
cargo run # 运行（run）工程
cargo clippy # 类似eslint，lint工具检查代码可以优化的地方
cargo fmt # 类似go fmt，代码格式化
cargo tree # 查看第三方库的版本和依赖关系
cargo bench # 运行benchmark(基准测试,性能测试)
cargo udeps # (第三方): 检查项目中未使用的依赖
cargo build/run --release  # 使用 release 编译会比默认的 debug 编译性能提升 10 倍以上，但是 release 缺点是编译速度较慢，而且不会显示 panic backtrace 的具体行号
```

## 1.2 输出到命令行

> 在之前的 Hello, World 程序中大概已经告诉了大家输出字符串的方式，但并不全面，大家可能很疑惑为什么 println!( "Hello World") 中的 println 后面还有一个 ! 符号，难道 Rust 函数之后都要加一个感叹号？显然并不是这样。**println 不是一个函数，而是一个宏规则**。这里不需要更深刻的挖掘宏规则是什么，后面的章节中会专门介绍，并不影响接下来的一段学习。

​	Rust 输出文字的方式主要有两种：

+ **println!()** 
+  **print!()**

​	这两个"函数"都是向命令行输出字符串的方法，区别仅在于前者会在输出的最后附加输出一个换行符。当用这两个"函数"输出信息的时候，第一个参数是格式字符串，后面是一串可变参数，对应着格式字符串中的"占位符"，这一点与 C 语言中的 printf 函数很相似。但是，<u>Rust 中格式字符串中的占位符不是"% + 字母"的形式，而是一对 {}</u>。

```rust
fu main() {
	let a = 12;
  println!("a is {}", a);
}
```

```shell
cargo run
# 输出
a is 12
```

**在 {} 之间可以放一个数字，它将把之后的可变参数当作一个数组来访问，下标从 0 开始。**

```rust
fn main() {
    let a = 12;
    println!("Hello, {0}, {0}", a);
}
```

```shell
cargo run
# 输出
a is 12 12
```

<u>如果要输出 **{** 或 **}** 怎么办呢？格式字符串中通过 **{{** 和 **}}** 分别转义代表 { 和 }。但是其他常用转义字符与 C 语言里的转义字符一样，都是反斜杠开头的形式。</u>

```rust
fn main() {
    let a = 12;
    println!("Hello, {0}, {0} , {{}}", a);
}
```

```shell
cargo run
# 输出
Hello, 12, 12 , {}
```

# 2. 基础语法

## 变量

**Rust是强类型语言，但具有自动判断变量类型的能力**。

如果要声明变量，需要使用`let`关键字，例如：

```rust
let a = 123;
```

只学习过 JavaScript 的开发者对这句话很敏感，只学习过 C 语言的开发者对这句话很不理解。

在这句声明语句之后，以下三行代码都是被禁止的：

```rust
a = "abc";
a = 4.56; 
a = 456;
```

第一行的错误在于当声明 a 是 123 以后，a 就被确定为整型数字，不能把字符串类型的值赋给它。

第二行的错误在于自动转换数字精度有损失，**Rust 语言不允许精度有损失的自动数据类型转换**。

第三行的错误在于 a **不是个可变变量**。

> 前两种错误很容易理解，但第三个是什么意思？难道 a 不是个变量吗？
>
> 这就牵扯到了 Rust 语言为了高并发安全而做的设计：**在语言层面尽量少的让变量的值可以改变**。所以 a 的值不可变。但这不意味着 a 不是"变量"（英文中的 variable），官方文档称 a 这种变量为"不可变变量"。
>
> <u>如果我们编写的程序的一部分在假设值永远不会改变的情况下运行，而我们代码的另一部分在改变该值，那么代码的第一部分可能就不会按照设计的意图去运转。由于这种原因造成的错误很难在事后找到。这是 Rust 语言设计这种机制的原因</u>。

**使变量变得"可变"（mutable）只需一个 mut 关键字**。

```rust
let mut a = 123;
a = 456;
```

## 常量和不可变变量的区别

既然不可变变量是不可变的，那不就是常量吗？为什么叫变量？

变量和常量还是有区别的。在 Rust 中，以下程序是合法的：

```rust
let a = 123;
let a = 456;
```

但是如果 a 是常量就不合法：

```rust
const a: i32 = 123;
let a = 456;
```

<u>变量的值可以"重新绑定"，但在"重新绑定"以前不能私自被改变，这样可以确保在每一次"绑定"之后的区域里编译器可以充分的推理程序逻辑</u>。

 虽然 Rust 有自动判断类型的功能，但有些情况下声明类型更加方便：

```rust
let a: u64 = 123;
```

这里声明了 a 为无符号 64 位整型变量，**如果没有声明类型，a 将自动被判断为有符号 32 位整型变量**，这对于 a 的取值范围有很大的影响。

## 重影（Shadowing）

重影的概念与其他面向对象语言里的"重写"（Override）或"重载"（Overload）是不一样的。重影就是刚才讲述的所谓"重新绑定"，之所以加引号就是为了在没有介绍这个概念的时候代替一下概念。

**重影就是指变量的名称可以被重新使用的机制**：

```rust
fn main() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!("The value of x is: {}", x);
}
```

```shell
The value of x is: 12
```

+ 重影与可变变量的赋值不是一个概念，<u>重影是指用同一个名字重新代表另一个变量实体</u>，**其类型、可变属性和值都可以变化**。
+ 但**可变变量赋值仅能发生值的变化**。

```rust
let mut s = "123";
s = s.len();
```

这段程序会出错：不能给字符串变量赋整型值。 

# 3. 数据类型

## 整数型(Integer)

整数型简称整型，按照比特位长度和有无符号分为一下种类：

| 位长度  | 有符号 | 无符号 |
| :------ | :----- | :----- |
| 8-bit   | i8     | u8     |
| 16-bit  | i16    | u16    |
| 32-bit  | i32    | u32    |
| 64-bit  | i64    | u64    |
| 128-bit | i128   | u128   |
| arch    | isize  | usize  |

<u>isize 和 usize 两种整数类型是用来衡量数据大小的，它们的**位长度取决于所运行的目标平台**，如果是 32 位架构的处理器将使用 32 位位长度整型</u>。

整数的表述方法有以下几种：

| 进制                 | 例          |
| :------------------- | :---------- |
| 十进制               | 98_222      |
| 十六进制             | 0xff        |
| 八进制               | 0o77        |
| 二进制               | 0b1111_0000 |
| 字节(只能表示 u8 型) | b'A'        |

很显然，<u>有的整数中间存在一个下划线，这种设计可以让人们在输入一个很大的数字时更容易判断数字的值大概是多少</u>。

## 浮点数型(Floating-Point)

Rust 与其它语言一样支持 32 位浮点数（f32）和 64 位浮点数（f64）。**默认情况下，64.0 将表示 64 位浮点数**，<u>因为现代计算机处理器对两种浮点数计算的速度几乎相同，但 64 位浮点数精度更高</u>。

```rust
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
}
```

### 数学运算

用一段程序反应数学运算：

```rust
fn main() {
    let sum = 5 + 10; // 加
    let difference = 95.5 - 4.3; // 减
    let product = 4 * 30; // 乘
    let quotient = 56.7 / 32.2; // 除
    let remainder = 43 % 5; // 求余
}
```

许多运算符号之后加上 = 号是自运算的意思，例如：

**sum += 1** 等同于 **sum = sum + 1**。

> **注意：**Rust 不支持 **++** 和 **--**，因为这两个运算符出现在变量的前后会影响代码可读性，减弱了开发者对变量改变的意识能力。

## 布尔型

布尔型用 bool 表示，值只能为 true 或 false。

## 字符型

字符型用 char 表示。

**Rust的 char 类型大小为 4 个字节**，代表 Unicode标量值，这意味着它可以支持中文，日文和韩文字符等非英文字符甚至表情符号和零宽度空格在 Rust 中都是有效的 char 值。

Unicode 值的范围从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF （包括两端）。 但是，"字符"这个概念并不存在于 Unicode 中，因此您对"字符"是什么的直觉可能与Rust中的字符概念不匹配。所以**一般推荐使用字符串储存 UTF-8 文字（非英文字符尽可能地出现在字符串中）**。

> **注意：**由于中文文字编码有两种（GBK 和 UTF-8），所以编程中使用中文字符串有可能导致乱码的出现，这是因为源程序与命令行的文字编码不一致，所以在 Rust 中字符串和字符都必须使用 UTF-8 编码，否则编译器会报错。

## 复合类型

元组用一对 **( )** 包括的一组数据，可以包含不同种类的数据：

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
// tup.0 等于 500
// tup.1 等于 6.4
// tup.2 等于 1
let (x, y, z) = tup;
// y 等于 6.4
```

数组用一对 **[ ]** 包括的同类型数据。

```rust
let a = [1, 2, 3, 4, 5];
// a 是一个长度为 5 的整型数组

let b = ["January", "February", "March"];
// b 是一个长度为 3 的字符串数组

let c: [i32; 5] = [1, 2, 3, 4, 5];
// c 是一个长度为 5 的 i32 数组

let d = [3; 5];
// 等同于 let d = [3, 3, 3, 3, 3];

let first = a[0];
let second = a[1];
// 数组访问

a[0] = 123; // 错误：数组 a 不可变
let mut a = [1, 2, 3];
a[0] = 4; // 正确
```

# 4. 注释

Rust 中的注释方式与其它语言（C、Java）一样，支持两种注释方式：

```rust
// 这是第一种注释方式

/* 这是第二种注释方式 */

/*
 * 多行注释
 * 多行注释
 * 多行注释
 */
```

## 用于说明文档的注释

在 Rust 中使用 **//** 可以使其之后到第一个换行符的内容变成注释。

在这种规则下，三个反斜杠 **///** 依然是合法的注释开始。所以 Rust 可以用 **///** 作为说明文档注释的开头：

```rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let x = add(1, 2);
///
/// ```

fn add(a: i32, b: i32) -> i32 {
    return a + b;
}
   
fn main() {
    println!("{}",add(2,3));
}
```

程序中的函数 add 就会拥有一段优雅的注释，并可以显示在 IDE 中：

![img](https://www.runoob.com/wp-content/uploads/2020/04/comment-rust.png)

> **Tip：**Cargo 具有 cargo doc 功能，开发者可以通过这个命令将工程中的说明注释转换成 HTML 格式的说明文档。

# 5. 函数

函数在 Rust 语言中是普遍存在的。

通过之前的章节已经可以了解到 Rust 函数的基本形式：

```rust
fn <函数名> ( <参数> ) <函数体>
```

其中 **Rust 函数名称的命名风格是小写字母以下划线分割**：

```rust
fn main() {
    println!("Hello, world!");
    another_function();
}

fn another_function() {
    println!("Hello, runoob!");
}
```

```shell
Hello, world!
Hello, runoob!
```

> 注意，我们在源代码中的 main 函数之后定义了another_function。 Rust不在乎您在何处定义函数，只需在某个地方定义它们即可。

## 函数参数

Rust 中定义函数如果需要具备参数必须声明**参数名称**和**类型**：

```rust
fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!("x 的值为 : {}", x);
    println!("y 的值为 : {}", y);
}
```

```shell
x 的值为 : 5
y 的值为 : 6
```

## 函数体的语句和表达式

Rust 函数体由一系列可以以表达式（Expression）结尾的语句（Statement）组成。到目前为止，我们仅见到了没有以表达式结尾的函数，但已经将表达式用作语句的一部分。

**语句是执行某些操作且没有返回值的步骤**。例如：

```rust
let a = 6;
```

这个步骤没有返回值，所以以下语句不正确：

```rust
let a = (let b = 2);
```

**表达式有计算步骤且有返回值**。

以下是表达式（假设出现的标识符已经被定义）：

```rust
a = 7
b + 2
c * (a + b)
```

**Rust 中可以在一个用 {} 包括的块里编写一个较为复杂的表达式**：

```rust
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("x 的值为 : {}", x);
    println!("y 的值为 : {}", y);
}
```

```shell
x 的值为 : 5
y 的值为 : 4
```

很显然，这段程序中包含了一个表达式块：

```rust
{
    let x = 3;
    x + 1
};
```

<u>而且在块中可以使用函数语句，最后一个步骤是表达式，此表达式的结果值是整个表达式块所代表的值。这种表达式块叫做**函数体表达式**</u>。

注意：**x + 1** 之后没有分号，否则它将变成一条语句！

这种**表达式块是一个合法的函数体**。而且**在 Rust 中，函数定义可以嵌套**：

```rust
fn main() {
    fn five() -> i32 {
        5
    }
    println!("five() 的值为: {}", five());
}
```

## 函数返回值

在上一个嵌套的例子中已经显示了 Rust 函数声明返回值类型的方式：**在参数声明之后用 -> 来声明函数返回值的类型（不是 : ）**。

**在函数体中，随时都可以以 return 关键字结束函数运行并返回一个类型合适的值**。这也是最接近大多数开发者经验的做法：

```rust
fn add(a: i32, b: i32) -> i32 {
    return a + b;
}
```

但是 **Rust 不支持自动返回值类型判断**！

<u>如果没有明确声明函数返回值的类型，函数将被认为是"纯过程"，不允许产生返回值，return 后面不能有返回值表达式</u>。这样做的目的是为了让公开的函数能够形成可见的公报。

> **注意：**函数体表达式并不能等同于函数体，它不能使用 **return** **关键字。**

# 6. 条件语句

在 Rust 语言中的条件语句是这种格式的：

```rust
fn main() {
    let number = 3;
    if number < 5 {
        println!("条件为 true");
    } else {
        println!("条件为 false");
    }
}
```

在上述程序中有条件 if 语句，这个语法在很多其它语言中很常见，但也有一些区别：

首先，**条件表达式 number < 5 不需要用小括号包括（注意，不需要不是不允许）**；

但是 **Rust 中的 if 不存在单语句不用加 {} 的规则，不允许使用一个语句代替一个块**。

尽管如此，Rust 还是支持传统 else-if 语法的：

```rust
fn main() {
    let a = 12;
    let b;
    if a > 0 {
        b = 1;
    }  
    else if a < 0 {
        b = -1;
    }  
    else {
        b = 0;
    }
    println!("b is {}", b);
}
```

```shell
b 为 1
```

Rust 中的**条件表达式必须是 bool 类型**，例如下面的程序是错误的：

```rust
fn main() {
    let number = 3;
    if number {   // 报错，expected `bool`, found integerrustc(E0308)
        println!("Yes");
    }
}
```

虽然 C/C++ 语言中的条件表达式用整数表示，非 0 即真，但这个规则在很多注重代码安全性的语言中是被禁止的。

结合之前章学习的函数体表达式我们加以联想：

```rust
if <condition> { block 1 } else { block 2 } 
```

这种语法中的 **{ block 1 }** 和 **{ block 2 }** 可不可以是函数体表达式呢？

答案是肯定的！也就是说，<u>在 Rust 中我们可以使用 if-else 结构实现类似于三元条件运算表达式 **(A ? B : C)** 的效果</u>：

```rust
fn main() {
    let a = 3;
    let number = if a > 0 { 1 } else { -1 };
    println!("number 为 {}", number);
}
```

```shell
number 为 1
```

> **注意**：<u>两个函数体表达式的**类型必须一样**！且必须有一个 else 及其后的表达式块</u>。

# 7. 循环

Rust 除了灵活的条件语句以外，循环结构的设计也十分成熟。这一点作为身经百战的开发者应该能感觉出来。

## while循环

while 循环是最典型的条件语句循环：

```rust
fn main() {
    let mut number = 1;
    while number != 4 {
        println!("{}", number);
        number += 1;
    }
    println!("EXIT");
}
```

```shell
1
2
3
EXIT
```

Rust 语言到此教程编撰之日还没有 do-while 的用法，但是 do 被规定为保留字，也许以后的版本中会用到。

**在 C 语言中 for 循环使用三元语句控制循环，但是 Rust 中没有这种用法，需要用 while 循环来代替**：

```c
int i;
for (i = 0; i < 10; i++) {
    // 循环体
}
```

```rust
let mut i = 0;
while i < 10 {
    // 循环体
    i += 1;
}
```

## for循环

for 循环是最常用的循环结构，常用来遍历一个线性数据据结构（比如数组）。for 循环遍历数组：

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    for i in a.iter() {
        println!("值为 : {}", i);
    }
}
```

```shell
值为 : 10
值为 : 20
值为 : 30
值为 : 40
值为 : 50
```

这个程序中的 for 循环完成了对数组 a 的遍历。**a.iter() 代表 a 的迭代器（iterator）**，在学习有关于对象的章节以前不做赘述。

当然，for 循环其实是可以通过下标来访问数组的：

```rust
fn main() {
let a = [10, 20, 30, 40, 50];
    for i in 0..5 {
        println!("a[{}] = {}", i, a[i]);
    }
}
```

```shell
a[0] = 10
a[1] = 20
a[2] = 30
a[3] = 40
a[4] = 50
```

## loop循环

身经百战的开发者一定遇到过几次这样的情况：某个循环无法在开头和结尾判断是否继续进行循环，必须在循环体中间某处控制循环的进行。如果遇到这种情况，我们经常会在一个 while (true) 循环体里实现中途退出循环的操作。

**Rust 语言有原生的<u>无限循环结构</u> —— loop**：

```rust
fn main() {
    let s = ['R', 'U', 'N', 'O', 'O', 'B'];
    let mut i = 0;
    loop {
        let ch = s[i];
        if ch == 'O' {
            break;
        }
        println!("\'{}\'", ch);
        i += 1;
    }
}
```

```shell
'R' 
'U' 
'N' 
```

**loop 循环可以通过 break 关键字类似于 return 一样使整个循环退出并给予外部一个返回值**。

这是一个十分巧妙的设计，因为 loop 这样的循环常被用来当作查找工具使用，如果找到了某个东西当然要将这个结果交出去：

```rust
fn main() {
    let s = ['R', 'U', 'N', 'O', 'O', 'B'];
    let mut i = 0;
    let location = loop {
        let ch = s[i];
        if ch == 'O' {
            break i;
        }
        i += 1;
    };
    println!(" \'O\' 的索引为 {}", location);
}
```

```shell
 'O' 的索引为 3
```

# 8. 所有权

计算机程序必须在运行时管理它们所使用的内存资源。

大多数的编程语言都有管理内存的功能：

+ <u>C/C++ 这样的语言主要通过手动方式管理内存，开发者需要手动的申请和释放内存资源。但为了提高开发效率，只要不影响程序功能的实现，许多开发者没有及时释放内存的习惯。所以手动管理内存的方式常常造成资源浪费</u>。

+ <u>Java 语言编写的程序在虚拟机（JVM）中运行，JVM 具备自动回收内存资源的功能。但这种方式常常会降低运行时效率，所以 JVM 会尽可能少的回收资源，这样也会使程序占用较大的内存资源</u>。

所有权对大多数开发者而言是一个新颖的概念，它是 Rust 语言为高效使用内存而设计的语法机制。所有权概念是为了让 Rust 在编译阶段更有效地分析内存资源的有用性以实现内存管理而诞生的概念。

## 所有权规则

所有权有以下三条规则：

- **Rust 中的每个值都有一个变量，称为其所有者**。
- **一次只能有一个所有者**。
- **当所有者不在程序运行范围时，该值将被删除**。

这三条规则是所有权概念的基础。

接下来将介绍与所有权概念有关的概念。

### 变量范围

我们用下面这段程序描述变量范围的概念：

```rust
{
    // 在声明以前，变量 s 无效
    let s = "runoob";
    // 这里是变量 s 的可用范围
}
// 变量范围已经结束，变量 s 无效
```

<u>变量范围是变量的一个属性，其代表变量的可行域，默认从声明变量开始有效直到变量所在域结束</u>。

### 内存和分配

如果我们定义了一个变量并给它赋予一个值，这个变量的值存在于内存中。这种情况很普遍。但如果我们需要储存的数据长度不确定（比如用户输入的一串字符串），我们就无法在定义时明确数据长度，也就无法在编译阶段令程序分配固定长度的内存空间供数据储存使用。（有人说分配尽可能大的空间可以解决问题，但这个方法很不文明）。**这就需要提供一种在程序运行时程序自己申请使用内存的机制——堆。本章所讲的所有"内存资源"都指的是堆所占用的内存空间**。

有分配就有释放，程序不能一直占用某个内存资源。因此决定资源是否浪费的关键因素就是资源有没有及时的释放。

我们把字符串样例程序用 C 语言等价编写：

```c
{
    char *s = strdup("runoob");
    free(s); // 释放 s 资源
}
```

很显然，Rust 中没有调用 free 函数来释放字符串 s 的资源（我知道这样在 C 语言中是不正确的写法，因为 "runoob" 不在堆中，这里假设它在）。**<u>Rust 之所以没有明示释放的步骤是因为在变量范围结束的时候，Rust 编译器自动添加了调用释放资源函数的步骤</u>**。

<u>这种机制看似很简单了：它不过是帮助程序员在适当的地方添加了一个释放资源的函数调用而已。但这种简单的机制可以有效地解决一个史上最令程序员头疼的编程问题</u>。

## 变量与数据交互的方式

变量与数据交互方式主要有移动（Move）和克隆（Clone）两种：

### 移动

多个变量可以在 Rust 中以不同的方式与相同的数据交互：

```rust
let x = 5;
let y = x;
```

这个程序将值 5 绑定到变量 x，然后将 x 的值复制并赋值给变量 y。现在栈中将有两个值 5。<u>此情况中的数据是"基本数据"类型的数据，不需要存储到堆中，**仅在栈中的数据的"移动"方式是直接复制**，这不会花费更长的时间或更多的存储空间</u>。"基本数据"类型有这些：

- 所有整数类型，例如 i32 、 u32 、 i64 等。
- 布尔类型 bool，值为 true 或 false 。
- 所有浮点类型，f32 和 f64。
- 字符类型 char。
- **仅包含以上类型数据的元组（Tuples）**。

但如果发生交互的数据在堆中就是另外一种情况：

```rust
let s1 = String::from("hello");
let s2 = s1;
```

第一步产生一个 String 对象，值为 "hello"。其中 "hello" 可以认为是类似于长度不确定的数据，需要在堆中存储。

第二步的情况略有不同（**这不是完全真的，仅用来对比参考**）：

![img](https://www.runoob.com/wp-content/uploads/2020/04/rust-ownership1.png)

如图所示：两个 String 对象在栈中，每个 String 对象都有一个指针指向堆中的 "hello" 字符串。在给 s2 赋值时，只有栈中的数据被复制了，堆中的字符串依然还是原来的字符串。

前面我们说过，**当变量超出范围时，Rust 自动调用释放资源函数并清理该变量的堆内存**。<u>但是 s1 和 s2 都被释放的话堆区中的 "hello" 被释放两次，这是不被系统允许的</u>。<u>**为了确保安全，在给 s2 赋值时 s1 已经无效了。没错，在把 s1 的值赋给 s2 以后 s1 将不可以再被使用**</u>。下面这段程序是错的：

```rust
let s1 = String::from("hello");
let s2 = s1; 
println!("{}, world!", s1); // 错误！s1 已经失效
```

所以实际情况是：

![img](https://www.runoob.com/wp-content/uploads/2020/04/rust-ownership2.png)

s1 名存实亡。

### 克隆

Rust会尽可能地降低程序的运行成本，所以默认情况下，长度较大的数据存放在堆中，且采用移动的方式进行数据交互。

但**如果需要将数据单纯的复制一份以供他用，可以使用数据的第二种交互方式——克隆**。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();
    println!("s1 = {}, s2 = {}", s1, s2);
}
```

```shell
s1 = hello, s2 = hello
```

这里是真的将堆中的 "hello" 复制了一份，所以 s1 和 s2 都分别绑定了一个值，释放的时候也会被当作两个资源。

当然，**克隆仅在需要复制的情况下使用，毕竟复制数据会花费更多的时间**。

## 涉及函数的所有权机制

对于变量来说这是最复杂的情况了。

如果将一个变量当作函数的参数传给其他函数，怎样安全的处理所有权呢？

下面这段程序描述了这种情况下所有权机制的运行原理：

```rust
fn main() {
    let s = String::from("hello");
    // s 被声明有效

    takes_ownership(s);
    // s 的值被当作参数传入函数
    // 所以可以当作 s 已经被移动，从这里开始已经无效

    let x = 5;
    // x 被声明有效

    makes_copy(x);
    // x 的值被当作参数传入函数
    // 但 x 是基本类型，依然有效
    // 在这里依然可以使用 x 却不能使用 s

} // 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放


fn takes_ownership(some_string: String) {
    // 一个 String 参数 some_string 传入，有效
    println!("{}", some_string);
} // 函数结束, 参数 some_string 在这里释放

fn makes_copy(some_integer: i32) {
    // 一个 i32 参数 some_integer 传入，有效
    println!("{}", some_integer);
} // 函数结束, 参数 some_integer 是基本类型, 无需释放
```

<u>如果将变量当作参数传入函数，那么它和移动的效果是一样的</u>。

### 函数返回值的所有权机制

```rust
fn main() {
    let s1 = gives_ownership();
    // gives_ownership 移动它的返回值到 s1

    let s2 = String::from("hello");
    // s2 被声明有效

    let s3 = takes_and_gives_back(s2);
    // s2 被当作参数移动, s3 获得返回值所有权
} // s3 无效被释放, s2 被移动, s1 无效被释放.

fn gives_ownership() -> String {
    let some_string = String::from("hello");
    // some_string 被声明有效

    return some_string;
    // some_string 被当作返回值移动出函数
}

fn takes_and_gives_back(a_string: String) -> String { 
    // a_string 被声明有效

    a_string  // a_string 被当作返回值移出函数
}
```

**被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放**。

## 引用与租借

引用（Reference）是 C++ 开发者较为熟悉的概念。

如果你熟悉指针的概念，你可以把它看作一种指针。

**实质上"引用"是变量的间接访问方式**。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = &s1;
    println!("s1 is {}, s2 is {}", s1, s2);
}
```

```shell
s1 is hello, s2 is hello
```

**&** 运算符可以取变量的"引用"。

**当一个变量的值被引用时，变量本身不会被认定无效**。因为"引用"并没有在栈中复制变量的值：

![img](https://www.runoob.com/wp-content/uploads/2020/04/F25111E7-C5D3-464A-805D-D2186A30C8A0.jpg)

函数参数传递的道理一样：

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

运行结果：

```shell
The length of 'hello' is 5.
```

**引用不会获得值的所有权**。

**<u>引用只能租借（Borrow）值的所有权</u>**。

**引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权**：

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = &s1;
    let s3 = s1;
    println!("{}", s2);
}
```

**<u>这段程序不正确：因为 s2 租借的 s1 已经将所有权移动到 s3，所以 s2 将无法继续租借使用 s1 的所有权。如果需要使用 s2 使用该值，必须重新租借</u>**：

```rust
fn main() {
    let s1 = String::from("hello");
    let mut s2 = &s1;
    let s3 = s2;
    s2 = &s3; // 重新从 s3 租借所有权
    println!("{}", s2);
}
```

这段程序是正确的。

<u>既然引用不具有所有权，即使它租借了所有权，它也只享有使用权</u>（这跟租房子是一个道理）。

<u>**如果尝试利用租借来的权利来修改数据会被阻止**</u>：

```rust
fn main() {
    let s1 = String::from("run");
    let s2 = &s1;
    println!("{}", s2);
    s2.push_str("oob"); // 错误，禁止修改租借的值
    println!("{}", s2);
}
```

这段程序中 s2 尝试修改 s1 的值被阻止，**<u>租借的所有权不能修改所有者的值</u>**。

当然，也存在一种可变的租借方式，就像你租一个房子，如果物业规定房主可以修改房子结构，房主在租借时也在合同中声明赋予你这种权利，你是可以重新装修房子的：

```rust
fn main() {
    let mut s1 = String::from("run");
    // s1 是可变的

    let s2 = &mut s1;
    // s2 是可变的引用

    s2.push_str("oob");
    println!("{}", s2);
}
```

这段程序就没有问题了。**<u>我们用 &mut 修饰可变的引用类型</u>**。

**<u>可变引用与不可变引用相比除了权限不同以外，可变引用不允许多重引用，但不可变引用可以</u>**：

```rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
```

**这段程序不正确，因为多重可变引用了 s**。

**<u>Rust 对可变引用的这种设计主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生</u>**。

<u>由于发生数据访问碰撞的必要条件之一是数据被至少一个使用者写且同时被至少一个其他使用者读或写，所以在**一个值被可变引用时不允许再次被任何引用**</u>。

### 垂悬引用（Dangling References）

**<u>这是一个换了个名字的概念，如果放在有指针概念的编程语言里它就指的是那种没有实际指向一个真正能访问的数据的指针（注意，不一定是空指针，还有可能是已经释放的资源）</u>**。

它们就像失去悬挂物体的绳子，所以叫"垂悬引用"。

**<u>"垂悬引用"在 Rust 语言里不允许出现，如果有，编译器会发现它</u>**。

下面是一个垂悬的典型案例：

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

很显然，伴随着 dangle 函数的结束，其局部变量的值本身没有被当作返回值，被释放了。但它的引用却被返回，<u>**这个引用所指向的值已经不能确定的存在，故不允许其出现**</u>。

## 评论区补充

+ Rust 区别与其他高级语言的重要特征，在于其内存管理的两个特点：

  （1）变量超出作用域会自动释放。对于简单值类型的栈内存（如int，struct）超出作用域后自动释放，这个逻辑在各个语言都有实现。而对于 new 出来的堆内存，在c/c++中是要手动释放的，在java和dotnet中要委托垃圾回收释放或手动写 dispose 语句释放。而垃圾回收不是实时的，会影响性能。而释放语句总会有懒人忘记写的。而 **Rust 对栈内存和堆内存一视同仁，超出作用域一律自动释放**。Rust 的这个特点在兼顾性能的情况下、有效的减少了代码量和内存泄漏隐患。

  （2） “所有权” ：某段内存只能被最后的变量名所有，前面声明过的变量都作废，这有效的避免被多个变量释放的问题，而且该操作是在编译期就可以检查到的，这策略可在编译期就能有效的避免空指针问题。

+ **这部分对于所有权的设定，看起来很奇怪，其实本质上就是在语言层面禁止了同一个可变数据会有多个变量引用的情况，一旦作为参数传递了，就会发生所有权的移动（Move）或借用（Borrow）**。<u>赋值给另一个变量也就自动放弃了所有权。从根本上杜绝了并发情景下的数据共享冲突</u>。

# 9. Slice（切片）类型

**切片（Slice）是对数据值的部分引用**。

切片这个名字往往出现在生物课上，我们做样本玻片的时候要从生物体上获取切片，以供在显微镜上观察。在 Rust 中，切片的意思大致也是这样，只不过它从数据取材引用。

### 字符串切片

最简单、最常用的数据切片类型是字符串切片（String Slice）。

```rust
fn main() {
    let s = String::from("broadcast");

    let part1 = &s[0..5];
    let part2 = &s[5..9];

    println!("{}={}+{}", s, part1, part2);
}
```

运行结果：

```shell
broadcast=broad+cast
```

![img](https://www.runoob.com/wp-content/uploads/2020/04/rust-slice1.png)

上图解释了字符串切片的原理（注：Rust 中的字符串类型实质上记录了字符在内存中的起始位置和其长度，我们暂时了解到这一点）。

使用 **..** 表示范围的语法在循环章节中出现过。**x..y** 表示 **[x, y)** 的数学含义。**..** 两边可以没有运算数：

```shell
..y 等价于 0..y
x.. 等价于位置 x 到数据结束
.. 等价于位置 0 到结束
```

> **注意：**到目前为止，<u>尽量不要在字符串中使用非英文字符，因为编码的问题</u>。具体原因会在"字符串"章节叙述。

**被切片引用的字符串禁止更改其值**：

```rust
fn main() {
    let mut s = String::from("runoob");
    let slice = &s[0..3];
    s.push_str("yes!"); // 错误
    println!("slice = {}", slice);
}
```

这段程序不正确。

s 被部分引用，禁止更改其值。

实际上，到目前为止你一定疑惑为什么每一次使用字符串都要这样写**String::from("runoob")** ，直接写 **"runoob"** 不行吗？

事已至此我们必须分辨这两者概念的区别了。

在 Rust 中有两种常用的字符串类型：str 和 String。

**<u>str 是 Rust 核心语言类型，就是本章一直在讲的字符串切片（String Slice），常常以引用的形式出现（&str）</u>**。

<u>凡是用双引号包括的**字符串常量整体**的类型性质都是 **&str**</u>：

```rust
let s = "hello";
```

这里的 s 就是一个 &str 类型的变量。

String 类型是 Rust 标准公共库提供的一种数据类型，它的功能更完善——它支持字符串的追加、清空等实用的操作。<u>String 和 str 除了同样拥有一个**字符开始位置属性**和一个**字符串长度属性**以外还有一个**容量（capacity）属性**</u>。

**<u>String 和 str 都支持切片，切片的结果是 &str 类型的数据</u>**。

**注意：<u>切片结果必须是引用类型</u>，但开发者必须自己明示这一点**：

```rust
let slice = &s[0..3];
```

有一个快速的办法可以将 String 转换成 &str：

```rust
let s1 = String::from("hello");
let s2 = &s1[..];
```

### 非字符串切片

除了字符串以外，其他一些线性数据结构也支持切片操作，例如数组：

```rust
fn main() {
    let arr = [1, 3, 5, 7, 9];
    let part = &arr[0..3];
    for i in part.iter() {
        println!("{}", i);
    }
}
```

```shell
1
3
5
```

# 10. 结构体

Rust 中的结构体（Struct）与元组（Tuple）都可以将若干个类型不一定相同的数据捆绑在一起形成整体，但结构体的每个成员和其本身都有一个名字，这样访问它成员的时候就不用记住下标了。

**元组常用于非定义的多值传递，而结构体用于规范常用的数据结构**。

结构体的每个成员叫做"字段"。

## 结构体定义

```rust
struct Site {
    domain: String,
    name: String,
    nation: String,
    found: u32
}
```

> 注意：如果你常用 C/C++，请记住在 Rust 里 struct 语句仅用来定义，不能声明实例，结尾不需要 **;** 符号，而且每个字段定义之后用 **,** 分隔。

## 结构体实例

Rust 很多地方受 JavaScript 影响，在实例化结构体的时候用 JSON 对象的 **key: value** 语法来实现定义：

```rust
let runoob = Site {
    domain: String::from("www.runoob.com"),
    name: String::from("RUNOOB"),
    nation: String::from("China"),
    found: 2013
};
```

这样的好处是不仅使程序更加直观，还不需要按照定义的顺序来输入成员的值。

<u>如果正在实例化的结构体有字段名称和现存变量名称一样的，可以简化书写</u>：

```rust
let domain = String::from("www.runoob.com");
let name = String::from("RUNOOB");
let runoob = Site {
    domain,  // 等同于 domain : domain,
    name,    // 等同于 name : name,
    nation: String::from("China"),
    traffic: 2013
};
```

有这样一种情况：你想要新建一个结构体的实例，其中大部分属性需要被设置成与现存的一个结构体属性一样，仅需更改其中的一两个字段的值，可以使用<u>结构体更新语法</u>：

```rust
let site = Site {
    domain: String::from("www.runoob.com"),
    name: String::from("RUNOOB"),
    ..runoob
};
```

> 注意：**..runoob** 后面不可以有逗号。<u>**这种语法不允许一成不变的复制另一个结构体实例**，意思就是说至少重新设定一个字段的值才能引用其他实例的值</u>。

## 元组结构体

有一种更简单的定义和使用结构体的方式：**元组结构体**。

<u>元组结构体是一种形式是元组的结构体</u>。

<u>与元组的区别是它有名字和固定的类型格式</u>。它存在的意义是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据：

```rust
struct Color(u8, u8, u8);
struct Point(f64, f64);

let black = Color(0, 0, 0);
let origin = Point(0.0, 0.0);
```

"颜色"和"点坐标"是常用的两种数据类型，但如果实例化时写个大括号再写上两个名字就为了可读性牺牲了便捷性，Rust 不会遗留这个问题。**元组结构体对象的使用方式和元组一样，通过 `.` 和下标来进行访问**：

```rust
fn main() {
    struct Color(u8, u8, u8);
    struct Point(f64, f64);

    let black = Color(0, 0, 0);
    let origin = Point(0.0, 0.0);

    println!("black = ({}, {}, {})", black.0, black.1, black.2);
    println!("origin = ({}, {})", origin.0, origin.1);
}
```

```shell
black = (0, 0, 0)
origin = (0, 0)
```

## 结构体所有权

**<u>结构体必须掌握字段值所有权，因为结构体失效的时候会释放所有字段</u>**。

这就是为什么本章的案例中使用了 String 类型而不使用 &str 的原因。

但这不意味着结构体中不定义引用型字段，这需要通过"生命周期"机制来实现。

但现在还难以说明"生命周期"概念，所以只能在后面章节说明。

## 输出结构体

调试中，完整地显示出一个结构体实例是非常有用的。但如果我们手动的书写一个格式会非常的不方便。所以 Rust 提供了一个方便地输出一整个结构体的方法：

```rust
#[derive(Debug)]

struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 is {:?}", rect1);
}
```

如第一行所示：一定要导入调试库 **#[derive(Debug)]** ，之后在 println 和 print 宏中就可以用 **{:?}** 占位符输出一整个结构体：

```shell
rect1 is Rectangle { width: 30, height: 50 }
```

如果属性较多的话可以使用另一个占位符 **{:#?}** 。

输出结果：

```rust
rect1 is Rectangle {
    width: 30,
    height: 50
}
```

## 结构体方法

方法（Method）和函数（Function）类似，只不过它是用来操作结构体实例的。

如果你学习过一些面向对象的语言，那你一定很清楚函数一般放在类定义里并在函数中用 this 表示所操作的实例。

Rust 语言不是面向对象的，从它所有权机制的创新可以看出这一点。但是面向对象的珍贵思想可以在 Rust 实现。

**<u>结构体方法的第一个参数必须是 &self，不需声明类型，因为 self 不是一种风格而是关键字</u>**。

计算一个矩形的面积：

```rust
struct Rectangle {
    width: u32,
    height: u32,
}
   
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("rect1's area is {}", rect1.area());
}
```

```shell
rect1's area is 1500
```

<u>请注意，在调用结构体方法的时候不需要填写 self ，这是出于对使用方便性的考虑</u>。

一个多参数的例子：

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn wider(&self, rect: &Rectangle) -> bool {
        self.width > rect.width
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 40, height: 20 };

    println!("{}", rect1.wider(&rect2));
}
```

```shell
false
```

这个程序计算 rect1 是否比 rect2 更宽。

## 结构体关联函数

之所以"结构体方法"不叫"结构体函数"是因为"函数"这个名字留给了这种函数：它在 impl 块中却没有 &self 参数。

**<u>这种函数不依赖实例，但是使用它需要声明是在哪个 impl 块中的</u>**。

一直使用的 **String::from** 函数就是一个"关联函数"。

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn create(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }
}

fn main() {
    let rect = Rectangle::create(30, 50);
    println!("{:?}", rect);
}
```

```shell
Rectangle { width: 30, height: 50 }
```

> **贴士：**<u>结构体 impl 块可以写几次，效果相当于它们内容的拼接！</u>

## 单元结构体

结构体可以<u>只作为一种象征</u>而无需任何成员：

```rust
struct UnitStruct;
```

**我们称这种没有身体的结构体为单元结构体（Unit Struct）**。

# 11. 枚举类


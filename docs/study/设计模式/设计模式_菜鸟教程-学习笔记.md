# 设计模式_菜鸟教程-学习笔记

> [设计模式-菜鸟教程](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
>
> **标题标星号，表示我觉得比较重要的**。

# 0. 设计模式简介

## 0.1 GOF(四人帮，Gang of Four)

 在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 **Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）** 的书，该书首次提到了软件开发中设计模式的概念。

四位作者合称 **GOF（四人帮，全拼 Gang of Four）**。他们所提出的设计模式主要是基于以下的面向对象设计原则。

- **对接口编程而不是对实现编程。**
- **优先使用对象组合而不是继承。**

## 0.2 * 设计模式的类型

​	根据设计模式的参考书 **Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）** 中所提到的，总共有 23 种设计模式。

这些模式可以分为三大类：

+ 创建型模式（Creational Patterns）
+ 结构型模式（Structural Patterns）
+ 行为型模式（Behavioral Patterns）

当然，我们还会讨论另一类设计模式：J2EE 设计模式。

| 序号 | 模式 & 描述                                                  | 包括                                                         |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 1    | **创建型模式** <br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 | 工厂模式（Factory Pattern） <br/>抽象工厂模式（Abstract Factory Pattern） <br/>单例模式（Singleton Pattern） <br/>建造者模式（Builder Pattern） <br/>原型模式（Prototype Pattern） |
| 2    | **结构型模式** <br/>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 | 适配器模式（Adapter Pattern） <br/>桥接模式（Bridge Pattern） <br/>过滤器模式（Filter、Criteria Pattern） <br/>组合模式（Composite Pattern） <br/>装饰器模式（Decorator Pattern） <br/>外观模式（Facade Pattern） <br/>享元模式（Flyweight Pattern） <br/>代理模式（Proxy Pattern） |
| 3    | **行为型模式**  <br/>这些设计模式特别关注对象之间的通信。    | 责任链模式（Chain of Responsibility Pattern） <br/>命令模式（Command Pattern） <br/>解释器模式（Interpreter Pattern） <br/>迭代器模式（Iterator Pattern） <br/>中介者模式（Mediator Pattern） <br/>备忘录模式（Memento Pattern） <br/>观察者模式（Observer Pattern） <br/>状态模式（State Pattern） <br/>空对象模式（Null Object Pattern） <br/>策略模式（Strategy Pattern） <br/>模板模式（Template Pattern） <br/>访问者模式（Visitor Pattern） |
| 4    | **J2EE 模式**  <br/>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 | MVC 模式（MVC Pattern）<br/>业务代表模式（Business Delegate Pattern）<br/>组合实体模式（Composite Entity Pattern）<br/>数据访问对象模式（Data Access Object Pattern）<br/>前端控制器模式（Front Controller Pattern）<br/>拦截过滤器模式（Intercepting Filter Pattern）<br/>服务定位器模式（Service Locator Pattern）<br/>传输对象模式（Transfer Object Pattern）<br/>................................................................................................. |

下面用一个图片来整体描述一下设计模式之间的关系：

![设计模式之间的关系](https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg)

## 0.3 * 设计模式-七大原则

1. 开闭原则（Open Close Principle）

   开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

2. 里氏代换原则（Liskov Substitution Principle）

   里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

3. 依赖倒转原则（Dependence Inversion Principle）

   这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

4. 接口隔离原则（Interface Segregation Principle）

   这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

5. 迪米特法则，又称最少知道原则（Demeter Principle）

   最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

6. 合成复用原则（Composite Reuse Principle）

   合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。
   
7. 单一职责原则（Single Responsibilities Principle）

   单一职责原则其实就是为了提高内聚性一个说明，它的目的就保证了内聚性，只有一个引起变化的原因，说明类内成员之间的关系较高，内聚性不强的就不要写到一个类中。这就是单一职责的真正用意。

# 1. 工厂模式

​	工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

## 1.1 介绍

**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，<u>工厂模式使其创建过程延迟到子类进行</u>。

**主要解决：**主要解决接口选择的问题。

**何时使用：**我们明确地计划不同条件下创建不同实例时。

**如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。

**关键代码：**创建过程在其子类执行。

**应用实例：** 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。

**优点：** 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**使用场景：** 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

**注意事项：**作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是<u>复杂对象适合使用工厂模式</u>，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

## 1.2 实现

​	我们将创建一个 *Shape* 接口和实现 *Shape* 接口的实体类。下一步是定义工厂类 *ShapeFactory*。

​	*FactoryPatternDemo* 类使用 *ShapeFactory* 来获取 *Shape* 对象。它将向 *ShapeFactory* 传递信息（*CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。

![工厂模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg)

**步骤1**

创建一个接口：

```java
public interface Shape {
   void draw();
}
```

**步骤2**

创建实现接口的实体类。

```java
public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
```

```java
public class Square implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
```

```java
public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
```

**步骤3**

创建一个工厂，生成基于给定信息的实体类的对象。

```java
public class ShapeFactory {
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
```

**步骤4**

使用该工厂，通过传递类型信息来获取实体类的对象。

```java
public class FactoryPatternDemo {
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();
      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape("CIRCLE");
      //调用 Circle 的 draw 方法
      shape1.draw();
      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
      //调用 Rectangle 的 draw 方法
      shape2.draw();
      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape("SQUARE");
      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
```

**步骤5**

执行程序，输出结果：

```java
Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
```

## 1.3 评论区补充

1. 工厂模式概述

   > **一、一句话概括工厂模式**
   >
   > -  **简单工厂**：一个工厂类，一个产品抽象类。
   > -  **工厂方法**：多个工厂类，一个产品抽象类。
   > -  **抽象工厂**：多个工厂类，多个产品抽象类。
   >
   > **二、生活中的工厂模式**
   >
   > -  简单工厂类：一个麦当劳店，可以生产多种汉堡。
   > -  工厂方法类：一个麦当劳店，可以生产多种汉堡。一个肯德基店，也可以生产多种汉堡。
   > -  抽象工厂类：百胜餐饮集团下有肯德基和百事公司，肯德基生产汉堡，百事公司生成百事可乐。

# 2. 抽象工厂模式

​	抽象工厂模式（Abstract Factory Pattern）是围绕**一个超级工厂创建其他工厂**。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

## 2.1 介绍

**意图：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**主要解决：**主要解决接口选择的问题。

**何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**如何解决：**在一个产品族里面，定义多个产品。

**关键代码：**在一个工厂里聚合多个同类产品。

**应用实例：**工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

**使用场景：** 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。

**注意事项：**产品族难扩展，产品等级易扩展。

## 2.2 实现

​	我们将创建 *Shape* 和 *Color* 接口和实现这些接口的实体类。下一步是创建抽象工厂类 *AbstractFactory*。接着定义工厂类 *ShapeFactory* 和 *ColorFactory*，这两个工厂类都是扩展了 *AbstractFactory*。然后创建一个工厂创造器/生成器类 *FactoryProducer*。

​	*AbstractFactoryPatternDemo* 类使用 *FactoryProducer* 来获取 *AbstractFactory* 对象。它将向 *AbstractFactory* 传递形状信息 *Shape*（*CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。同时它还向 *AbstractFactory* 传递颜色信息 *Color*（*RED / GREEN / BLUE*），以便获取它所需对象的类型。

![抽象工厂模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg)

**步骤1**

为形状创建一个接口。

```java
public interface Shape {
   void draw();
}
```

**步骤2**

创建实现接口的实体类。

```java
public class Rectangle implements Shape {
  @Override
  public void draw() {
    System.out.println("Inside Rectangle::draw() method.");
  }
}
```

```java
public class Square implements Shape {
  @Override
  public void draw() {
    System.out.println("Inside Square::draw() method.");
  }
}
```

```java
public class Circle implements Shape {
  @Override
  public void draw() {
    System.out.println("Inside Circle::draw() method.");
  }
}
```

**步骤3**

为颜色创建一个接口。

```java
public interface Color {
  void fill();
}
```

**步骤4**

创建实现接口的实体类。

```java
public class Red implements Color {
  @Override
  public void fill() {
    System.out.println("Inside Red::fill() method.");
  }
}
```

```java
public class Green implements Color {
  @Override
  public void fill() {
    System.out.println("Inside Green::fill() method.");
  }
}
```

```java
public class Blue implements Color {
  @Override
  public void fill() {
    System.out.println("Inside Blue::fill() method.");
  }
}
```

**步骤5**

为 Color 和 Shape 对象创建抽象类来获取工厂。

```java
public abstract class AbstractFactory {
  public abstract Color getColor(String color);
  public abstract Shape getShape(String shape) ;
}
```

 **步骤6**

创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。

```java
public class ShapeFactory extends AbstractFactory {
  @Override
  public Shape getShape(String shapeType){
    if(shapeType == null){
      return null;
    }        
    if(shapeType.equalsIgnoreCase("CIRCLE")){
      return new Circle();
    } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
      return new Rectangle();
    } else if(shapeType.equalsIgnoreCase("SQUARE")){
      return new Square();
    }
    return null;
  }
  @Override
  public Color getColor(String color) {
    return null;
  }
}
```

```java
public class ColorFactory extends AbstractFactory {
  @Override
  public Shape getShape(String shapeType){
    return null;
  }
  @Override
  public Color getColor(String color) {
    if(color == null){
      return null;
    }        
    if(color.equalsIgnoreCase("RED")){
      return new Red();
    } else if(color.equalsIgnoreCase("GREEN")){
      return new Green();
    } else if(color.equalsIgnoreCase("BLUE")){
      return new Blue();
    }
    return null;
  }
}
```

**步骤7**

创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。

```java
public class FactoryProducer {
  public static AbstractFactory getFactory(String choice){
    if(choice.equalsIgnoreCase("SHAPE")){
      return new ShapeFactory();
    } else if(choice.equalsIgnoreCase("COLOR")){
      return new ColorFactory();
    }
    return null;
  }
}
```

**步骤8**

使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。

```java
public class AbstractFactoryPatternDemo {
  public static void main(String[] args) {
    //获取形状工厂
    AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
    //获取形状为 Circle 的对象
    Shape shape1 = shapeFactory.getShape("CIRCLE");
    //调用 Circle 的 draw 方法
    shape1.draw();
    //获取形状为 Rectangle 的对象
    Shape shape2 = shapeFactory.getShape("RECTANGLE");
    //调用 Rectangle 的 draw 方法
    shape2.draw();
    //获取形状为 Square 的对象
    Shape shape3 = shapeFactory.getShape("SQUARE");
    //调用 Square 的 draw 方法
    shape3.draw();
    //获取颜色工厂
    AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");
    //获取颜色为 Red 的对象
    Color color1 = colorFactory.getColor("RED");
    //调用 Red 的 fill 方法
    color1.fill();
    //获取颜色为 Green 的对象
    Color color2 = colorFactory.getColor("Green");
    //调用 Green 的 fill 方法
    color2.fill();
    //获取颜色为 Blue 的对象
    Color color3 = colorFactory.getColor("BLUE");
    //调用 Blue 的 fill 方法
    color3.fill();
  }
}
```

**步骤9**

执行程序，输出结果：

```java
Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
Inside Red::fill() method.
Inside Green::fill() method.
Inside Blue::fill() method.
```

## 2.3 * 评论区补充

1. 简单工厂模式、工厂模式、抽象工厂模式

   下面例子中鼠标，键盘，耳麦为产品，惠普，戴尔为工厂。

   **简单工厂模式**

   简单工厂模式不是 23 种里的一种，简而言之，就是有一个专门生产某个产品的类。

   比如下图中的鼠标工厂，专业生产鼠标，给参数 0，生产戴尔鼠标，给参数 1，生产惠普鼠标。

   ![img](https://www.runoob.com/wp-content/uploads/2018/07/1530601914-2143-DP-SimpleFactory.png)

   **工厂模式**

   工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。

   戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。

   生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。

   后续直接调用**鼠标工厂.生产鼠标()**即可

   ![img](https://www.runoob.com/wp-content/uploads/2018/07/1530601917-1999-DP-Factory.png)

   **抽象工厂模式**

   抽象工厂模式也就是不仅生产鼠标，同时生产键盘。

   也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。

   戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。

   创建工厂时，由戴尔工厂创建。

   后续**工厂.生产鼠标()**则生产戴尔鼠标，**工厂.生产键盘()**则生产戴尔键盘。

   ![img](https://www.runoob.com/wp-content/uploads/2018/07/1530601916-7298-DP-AbstractFactory.png)

   > 在抽象工厂模式中，假设我们需要增加一个工厂

   假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。

   之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。

   ![img](https://www.runoob.com/wp-content/uploads/2018/07/1530601980-8080-P-AbstractFactory-AddFactory.png)

   > 在抽象工厂模式中，假设我们需要增加一个产品

   假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。

   之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。 以上。

   ![img](https://www.runoob.com/wp-content/uploads/2018/07/1530601917-7462-P-AbstractFactory-AddProduct.png)

# 3. 单例模式

​	单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**注意：**

- 1、单例类只能有一个实例。
- 2、单例类必须自己创建自己的唯一实例。
- 3、单例类必须给所有其他对象提供这一实例。

## 3.1 介绍

**意图：**<u>保证一个类仅有一个实例，并提供一个访问它的全局访问点</u>。

**主要解决：**一个全局使用的类频繁地创建与销毁。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码：**构造函数是私有的。

**应用实例：**

- 1、一个班级只有一个班主任。
- 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
- 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。

**优点：**

- 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
- 2、<u>避免对资源的多重占用（比如写文件操作）</u>。

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**使用场景：**

- 1、要求生产唯一序列号。
- 2、<u>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来</u>。
- 3、<u>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等</u>。

**注意事项：**getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。

## 3.2 实现

我们将创建一个 *SingleObject* 类。*SingleObject* 类有它的私有构造函数和本身的一个静态实例。

*SingleObject* 类提供了一个静态方法，供外界获取它的静态实例。*SingletonPatternDemo* 类使用 *SingleObject* 类来获取 *SingleObject* 对象。

![单例模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/62576915-36E0-4B67-B078-704699CA980A.jpg)

**步骤1**

创建一个 Singleton 类。

```java
public class SingleObject {
  //创建 SingleObject 的一个对象
  private static SingleObject instance = new SingleObject();
  //让构造函数为 private，这样该类就不会被实例化
  private SingleObject(){}
  //获取唯一可用的对象
  public static SingleObject getInstance(){
    return instance;
  }
  public void showMessage(){
    System.out.println("Hello World!");
  }
}
```

**步骤2**

从 singleton 类获取唯一的对象。

```java
public class SingletonPatternDemo {
  public static void main(String[] args) {
    //不合法的构造函数
    //编译时错误：构造函数 SingleObject() 是不可见的
    //SingleObject object = new SingleObject();
    //获取唯一可用的对象
    SingleObject object = SingleObject.getInstance();
    //显示消息
    object.showMessage();
  }
}
```

**步骤3**

执行程序，输出结果：

```java
Hello World!
```

## 3.3 单例模式的几种实现方式

单例模式的实现有多种方式，如下所示：

### 1、懒汉式，线程不安全

**是否 Lazy 初始化：**是

**是否多线程安全：**否

**实现难度：**易

**描述：**这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。
这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。

```java
public class Singleton {  
  private static Singleton instance;  
  private Singleton (){}  
  public static Singleton getInstance() {  
    if (instance == null) {  
      instance = new Singleton();  
    }  
    return instance;  
  }  
}
```

**接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。**

### 2、懒汉式，线程安全

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**易

**描述：**这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。
**优点**：第一次调用才初始化，避免内存浪费。
**缺点**：必须加锁 synchronized 才能保证单例，但加锁会影响效率。
getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。

```java
public class Singleton {  
  private static Singleton instance;  
  private Singleton (){}  
  public static synchronized Singleton getInstance() {  
    if (instance == null) {  
      instance = new Singleton();  
    }  
    return instance;  
  }  
}
```

### 3、饿汉式

**是否 Lazy 初始化：**否

**是否多线程安全：**是

**实现难度：**易

**描述：**这种方式比较常用，但容易产生垃圾对象。
**优点**：没有加锁，执行效率会提高。
**缺点**：类加载时就初始化，浪费内存。
它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。

```java
public class Singleton {  
  private static Singleton instance = new Singleton();  
  private Singleton (){}  
  public static Singleton getInstance() {  
    return instance;  
  }  
}
```

### 4、双检锁/双重校验锁（DCL，即 double-checked locking）

**JDK 版本：**JDK1.5 起

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**较复杂

**描述：**这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
getInstance() 的性能对应用程序很关键。

```java
public class Singleton {  
  private volatile static Singleton singleton;  
  private Singleton (){}  
  public static Singleton getSingleton() {  
    if (singleton == null) {  
      synchronized (Singleton.class) {  
        if (singleton == null) {  
          singleton = new Singleton();  
        }  
      }  
    }  
    return singleton;  
  }  
}
```

### 5、登记式/静态内部类

> [关于final对象回收的疑问](https://bbs.csdn.net/topics/320255560)
>
> [final对象的生命周期](https://bbs.csdn.net/topics/220029494?page=2)	<=	很有意思的文章。强烈推荐阅读

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**一般

**描述：**这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。<u>这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用</u>。
这种方式同样**利用了 classloader 机制来保证初始化 instance 时只有一个线程**，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。

```java
public class Singleton {  
  private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
  }  
  private Singleton (){}  
  public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
  }  
}
```

### 6、* 枚举

> [为什么要用枚举实现单例模式（避免反射、序列化问题）](https://www.cnblogs.com/chiclee/p/9097772.html)	<=	推荐阅读
>
> [Java transient关键字使用小记](https://www.cnblogs.com/lanxuezaipiao/p/3369962.html)
>
> [为什么用枚举实现的单例模式可以防止反序列化？](https://leokongwq.github.io/2017/08/21/why-enum-singleton-are-serialization-safe.html)	<=	里面还有单例类如何防反射/反序列化攻击的解说
>
> + **反射**在java源码中会检查是否是Enum类型，是的话直接反射失败
>
> + Java的**序列化**机制针对枚举类型是特殊处理的。<u>简单来讲，在序列化枚举类型时，只会存储**枚举类的引用**和**枚举常量的名称**。随后的反序列化的过程中，这些信息被用来在运行时环境中查找存在的枚举类型对象</u>。
>
>   这样你就可以在同一个运行时环境中反序列化枚举常量，并且你会得到同一个实例对象。
>
>   然而，在不同的JVM中对枚举类型进行反序列化，可能会得到不同的`hashcode`。但是，对单例对象来说，拥有相同的`hashcode`并不是一个必要的条件。重点是该类永远不能有多余一个的实例(同一个JVM)，**<u>枚举类型的序列化机制保证只会查找已经存在的枚举类型实例，而不是创建新的实例</u>**。

**JDK 版本：**JDK1.5 起

**是否 Lazy 初始化：**否

**是否多线程安全：**是

**实现难度：**易

**描述：**这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动**支持序列化机制，绝对防止多次实例化**。
这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，**防止反序列化重新创建新的对象，绝对防止多次实例化**。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。
不能通过 reflection attack 来调用私有构造方法。

```java
public enum Singleton {  
  INSTANCE;  
  public void whateverMethod() {  
  }  
}
```

### * 经验之谈

一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。<u>如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式</u>。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。

## 3.4 * 评论区补充

> ps:
>
> + 序列化不需要调用构造函数
> + 反射调用无参构造函数

1. 懒汉式和饿汉式

   懒汉式与饿汉式的根本区别在与是否在类内方法外创建自己的对象。

   并且声明对象都需要私有化，构造方法都要私有化，这样外部才不能通过 new 对象的方式来访问。

   饿汉式的话是声明并创建对象(因为他饿)，懒汉式的话只是声明对象，在调用该类的 getinstance() 方法时才会进行 new 对象。

2. **反射机制破解单例模式（枚举除外）**

   ```java
   public class BreakSingleton{
     public static void main(String[] args) throw Exception{
       Class clazz = Class.forName("Singleton");
       Constructor c = clazz.getDeclaredConstructor(null);
   
       c.setAccessible(true);
   
       Singleton s1 = c.newInstance();
       Singleton s2 = c.newInstance();
       //通过反射，得到的两个不同对象
       System.out.println(s1);
       System.out.println(s2);
     }
   }
   ```

   避免以上楼漏洞的方法

   ```java
   class Singleton{
     private static final Singleton singleton = new Singleton(); 
     private Singleton() {
       //在构造器中加个逻辑判断,多次调用抛出异常
       if(instance!= null){
         throw new RuntimeException()
       }
     }
     public static Singleton getInstance(){
       return singleton;
     }
   }
   ```

3. **反序列化机制破解单例模式（枚举除外）**

   ```java
   public class BreakSingleton{
   
     public static void main(String[] args) throws Exception{
   
       //先根据单例模式创建对象(单例模式所以s1,s2是一样的)
       Singleton s1=Singleton.getInstance();
       Singleton s2=Singleton.getInstance();
   
       //将s1写入本地某个路径
       FileOutputStream fos=new FileOutputStream("本地某个路径下文件");
       ObjectOutputStream oos=new ObjectOutputStream(fos);
       oos.writeObject(s1);
       oos.close();
       fos.close();
   
       //从本地某个路径读取写入的对象
       ObjectInputStream ois=new ObjectInputStream(new FileInputStream("和上面的本地参数路径相同"));
       Singleton s3=(Singleton) ois.readObject();
       System.out.println(s1);
       System.out.println(s2);
       System.out.println(s3);//s3是一个新对象
     }
   
   }
   ```

   如何避免实现序列化单例模式的漏洞

   ```java
   class Singleton implements Serializable{
   
     private static final Singleton singleton = new Singleton(); 
   
     private Singleton() {
     }
     public static Singleton getInstance(){
       return singleton;
     }
     //反序列化定义该方法，则不需要创建新对象
     private Object readResolve() throws ObjectStreamException{
       return singleton;
     }
   }
   ```

4. 登记式单例模式是对一组单例模式进行的维护, 保证 map 中的对象是同一份 Spring 中使用的就是类似的模式

   ```java
   import java.util.Map;
   import java.util.concurrent.ConcurrentHashMap;
   
   public class RegisterSingleton {
     /** * 登记式单例模式, 保证map中的对象是同一份 */
     private static Map<String, Object> map;
   
     static {
       map = new ConcurrentHashMap<>();
       map.put(RegisterSingleton.class.getName(), new RegisterSingleton());
     }
   
     private RegisterSingleton() {
       System.out.println("this Constructor is called");
     }
   
     public static Object getInstance(String name) {
       if (name == null) {
         name = RegisterSingleton.class.getName();
       }
       if (map.get(name) == null) {
         try {
           map.put(name, Class.forName(name).newInstance());
         } catch (Exception e) {
           e.printStackTrace();
         }
       }
       return map.get(name);
     }
   }
   ```

> + [为什么用枚举实现的单例模式可以防止反序列化？](https://leokongwq.github.io/2017/08/21/why-enum-singleton-are-serialization-safe.html)
>
>   + 单例类防止反序列化
>
>     ```java
>     public class Singleton implements java.io.Serializable {
>       public static Singleton INSTANCE = new Singleton();
>       protected Singleton() {
>         // Exists only to thwart instantiation.
>       }
>       private Object readResolve() {
>         return INSTANCE;
>       }
>     }
>     ```
>
>   + 单例类如何防止反射？
>
>     ```java
>     public class Singleton {  
>       private static boolean flag = false;  
>       private Singleton(){  
>         synchronized(Singleton.class){  
>           if(flag == false){  
>             flag = !flag;  
>           } else {  
>             throw new RuntimeException("单例模式被侵犯！");  
>           }  
>         }  
>       }  
>       private  static class SingletonHolder {  
>         private static final Singleton INSTANCE = new Singleton();  
>       }  
>       public static Singleton getInstance(){  
>         return SingletonHolder.INSTANCE;  
>       }  
>     }
>     ```

# 4. 建造者模式

​	建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

## 4.1 介绍

**意图：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

**主要解决：**主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

**何时使用：**一些基本部件不会变，而其组合经常变化的时候。

**如何解决：**将变与不变分离开。

**关键代码：**建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。

**应用实例：** 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、<u>JAVA 中的 StringBuilder</u>。

**优点：** <u>1、建造者独立，易扩展。 2、便于控制细节风险。</u>

**缺点：** 1、产品必须有共同点，范围有限制。 2、<u>如内部变化复杂，会有很多的建造类</u>。

**使用场景：** 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。

**注意事项：**<u>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序</u>。

## 4.2 实现

​	我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。

​	我们将创建一个表示食物条目（比如汉堡和冷饮）的 *Item* 接口和实现 *Item* 接口的实体类，以及一个表示食物包装的 *Packing* 接口和实现 *Packing* 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。

​	然后我们创建一个 *Meal* 类，带有 *Item* 的 *ArrayList* 和一个通过结合 *Item* 来创建不同类型的 *Meal* 对象的 *MealBuilder*。*BuilderPatternDemo* 类使用 *MealBuilder* 来创建一个 *Meal*。

![建造者模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20210315-builder-pattern.svg)

**步骤 1**

创建一个表示食物条目和食物包装的接口。

```java
public interface Item {
  public String name();
  public Packing packing();
  public float price();    
}
```

```java
public interface Packing {
  public String pack();
}
```

**步骤 2**

创建实现 Packing 接口的实体类。

```java
public class Wrapper implements Packing {
  @Override
  public String pack() {
    return "Wrapper";
  }
}
```

```java
public class Bottle implements Packing {
  @Override
  public String pack() {
    return "Bottle";
  }
}
```

**步骤 3**

创建实现 Item 接口的抽象类，该类提供了默认的功能。

```java
public abstract class Burger implements Item {
  @Override
  public Packing packing() {
    return new Wrapper();
  }
  @Override
  public abstract float price();
}
```

```java
public abstract class ColdDrink implements Item {
  @Override
  public Packing packing() {
    return new Bottle();
  }
  @Override
  public abstract float price();
}
```

**步骤 4**

创建扩展了 Burger 和 ColdDrink 的实体类。

```java
public class VegBurger extends Burger {
  @Override
  public float price() {
    return 25.0f;
  }
  @Override
  public String name() {
    return "Veg Burger";
  }
}
```

```java
public class Coke extends ColdDrink {
  @Override
  public float price() {
    return 30.0f;
  }
  @Override
  public String name() {
    return "Coke";
  }
}
```

```java
public class Pepsi extends ColdDrink {
  @Override
  public float price() {
    return 35.0f;
  }
  @Override
  public String name() {
    return "Pepsi";
  }
}
```

**步骤 5**

创建一个 Meal 类，带有上面定义的 Item 对象。

```java
import java.util.ArrayList;
import java.util.List;

public class Meal {
  private List<Item> items = new ArrayList<Item>();    

  public void addItem(Item item){
    items.add(item);
  }

  public float getCost(){
    float cost = 0.0f;
    for (Item item : items) {
      cost += item.price();
    }        
    return cost;
  }

  public void showItems(){
    for (Item item : items) {
      System.out.print("Item : "+item.name());
      System.out.print(", Packing : "+item.packing().pack());
      System.out.println(", Price : "+item.price());
    }        
  }    
}
```

**步骤 6**

创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。

```java
public class MealBuilder {

  public Meal prepareVegMeal (){
    Meal meal = new Meal();
    meal.addItem(new VegBurger());
    meal.addItem(new Coke());
    return meal;
  }   

  public Meal prepareNonVegMeal (){
    Meal meal = new Meal();
    meal.addItem(new ChickenBurger());
    meal.addItem(new Pepsi());
    return meal;
  }
}
```

**步骤 7**

BuiderPatternDemo 使用 MealBuilder 来演示建造者模式（Builder Pattern）。

```java
public class BuilderPatternDemo {
  public static void main(String[] args) {
    MealBuilder mealBuilder = new MealBuilder();

    Meal vegMeal = mealBuilder.prepareVegMeal();
    System.out.println("Veg Meal");
    vegMeal.showItems();
    System.out.println("Total Cost: " +vegMeal.getCost());

    Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
    System.out.println("\n\nNon-Veg Meal");
    nonVegMeal.showItems();
    System.out.println("Total Cost: " +nonVegMeal.getCost());
  }
}
```

**步骤 8**

执行程序，输出结果：

```shell
Veg Meal
Item : Veg Burger, Packing : Wrapper, Price : 25.0
Item : Coke, Packing : Bottle, Price : 30.0
Total Cost: 55.0


Non-Veg Meal
Item : Chicken Burger, Packing : Wrapper, Price : 50.5
Item : Pepsi, Packing : Bottle, Price : 35.0
Total Cost: 85.5
```

## 4.3 * 相关文章

> - [设计模式之建造者(Builder)模式](https://www.runoob.com/w3cnote/builder-pattern.html)
> - [设计模式：Builder模式](https://www.runoob.com/w3cnote/builder-pattern-2.html)

![img](https://images2018.cnblogs.com/blog/1157683/201806/1157683-20180626180216963-8235726.png)

1. 前言

   今天我们讨论一下 Builder 建造者模式，这个 Builder，其实和模板模式非常的像，但是也有区别，那就是在模板模式中父类对子类中的实现进行操作，在父类之中进行一件事情的处理，但是在 Builder 模式之中，父类和子类都不用关心怎么处理，而是用另一个类来完成对这些方法的有机组合，这个类的职责就是**监工**，规定了到底要怎么样有机的组合这些方法。在监工类（Director）中，将父类组合进去，然后调用父类的操作来抽象的实现一件事情，这就是面向接口（抽象）变成的妙处了，当然这个 Builder 可以使接口也可以是抽象类，在这里我们使用抽象类。

2. 实现代码

   + Builder 抽象类：

     ```java
     public abstract class Builder {
       public abstract void makeString(String str);
       public abstract void makeTitle(String title);
       public abstract void makeItems(String[] items);
       public abstract void close();
     }
     ```

   + HtmlBuilder 实现类：

     ```java
     import java.io.FileWriter;
     import java.io.IOException;
     import java.io.PrintWriter;
     
     public class HtmlBuilder extends Builder {
     
       private String filename;
       private PrintWriter pw;
       public void makeTitle(String title) {
         filename="D:\\"+title+".html";
         try {
           pw=new PrintWriter(new FileWriter(filename));
         } catch (IOException e) {
           e.printStackTrace();
         }
         pw.println("<html><head><title>"+title+"</title></head><body>");
         pw.println("<h1>"+title+"</h1>");
       }
     
       public void makeString(String str) {
         pw.println("<p>"+str+"</p>");
       }
     
       public void makeItems(String[] items) {
         pw.println("<ul>");
         for(int i=0;i<items.length;i++){
           pw.println("<li>"+items[i]+"</li>");
         }
         pw.println("</ul>");
       }
     
       public void close() {
         pw.println("</body></html>");
         pw.close();
       }
       public String getResult(){
         return filename;
       }
     }
     ```

   + TextBuilder 实现类：

     ```java
     public class TextBuilder extends Builder {
     
       StringBuffer sb=new StringBuffer();
     
       public void makeTitle(String title) {
         sb.append("=====================");
         sb.append("["+title+"]"+"\n");
       }
     
       public void makeString(String str) {
         sb.append("@"+str+"\n");
       }
     
       public void makeItems(String[] items) {
         for(int i=0;i<items.length;i++){
           sb.append("   ."+items[i]+"\n");
         }
       }
     
       public void close() {
         sb.append("=====================");
       }
     
       public String getResult(){
         return sb.toString();
       }
     
     }
     ```

   + Director 监工类：

     ```java
     public class Director {
       private Builder builder;
       public Director(Builder builder){
         this.builder=builder;
       }
       public void construct(){
         String [] items1=new String[]{"奏国歌","升国旗"};
         String [] items2=new String[]{"观众鼓掌","有序撤离"};
         builder.makeTitle("今日头条");
         builder.makeString("毕业典礼");
         builder.makeItems(items1);
         builder.makeString("典礼结束");
         builder.makeItems(items2);
         builder.close();
       }
     }
     ```

   + Main 类：

     ```java
     public class Main {
     
       public static void main(String[] args) {
         //String choice="plain";
         String choice="html";
         if(choice=="plain"){
           TextBuilder t=new TextBuilder();
           Director d=new Director(t);
           d.construct();
           System.out.println(t.getResult());
         }else if(choice=="html"){
           HtmlBuilder html=new HtmlBuilder();
           Director d=new Director(html);
           d.construct();
           System.out.println(html.getResult());
         }else{
           usage();
         }
     
       }
     
       private static void usage() {
         System.out.println("使用 plain，编辑文本文件");
         System.out.println("使用 html，编辑网页文件");
       }
     
     }
     ```

3. 运行结果

   ![img](https://www.runoob.com/wp-content/uploads/2019/08/1157683-20180626181209288-2015291769.png)

4. 总结

   <small> 关于Builder模式，我们一定要分清和模板方法的区别，其实就是到底谁承担了“监工”的责任，在模板方法中父类承担了这个责任，而在Builder中，有另外一个专门的类来完成这样的操作，这样做的好处是类的隔离，比如说在Main中，用户根本就不知道有Builder这个抽象类，同样的Director这个监工的根本就不管到底是哪一个实现类，因为任何一个都会被转换为父类，然后进行处理（面向抽象编程的思想），因此很好的实现了隔离，同样的这样设计的好处是复用了，隔离的越好复用起来就越方便，我们完全可以思考，假如还有另外一个监工，使用了不同的construct方法来组装这些复杂的事件，那么对于原来的代码我们不用做任何的修改，只用增加这样的一个监工类，然后定义好相应的方法就好了，之后再Main中使用，这样的一种思想使得我们不用修改源代码，复用（Builder以及其子类）就很方便了，同样的，如果想增加一个新的Builder的子类，只要照着父类的方法进行填充，再加上自己的方法就好了，完全不用修改代码，这也是一种复用，因此这种复用（组件）的思想在设计模式中随处可见，本质就是高内聚低耦合，组件开发，尽量不修改原来的代码，有可扩展性，理解了这一点，我们再看看模板方法，责任全放在了父类里，如果责任需要改变，则必须要修改父类中的责任方法了，这样就修改了原来的代码，不利于复用，这也是两者的本质区别。</small>

## 4.4 评论区补充

1. 建造者模式三大角色：建造者、具体的建造者、监工。

   建造者模式，又称生成器模式：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

   +  **建造者角色**：定义生成实例所需要的所有方法；
   +  **具体的建造者角色**：实现生成实例所需要的所有方法，并且定义获取最终生成实例的方法；
   +  **监工角色**：<u>定义使用建造者角色中的方法来生成实例的方法</u>；

   > **注意**：定义中“**将一个复杂的构建过程与其表示相分离**”，表示并不是由建造者负责一切，而是<u>由监工负责控制（定义）一个复杂的构建过程，由各个不同的建造者分别负责实现构建过程中所用到的所有构建步骤</u>。不然，就无法做到“使得同样的构建过程可以创建不同的表示”这一目标。

   建造者角色：

   ```java
   public abstract class Builder {
     public abstract void buildPart1();
     public abstract void buildPart2();
     public abstract void buildPart3();
   }
   ```

   监工角色：

   ```java
   public class Director {    // 将一个复杂的构建过程与其表示相分离
     private Builder builder;    // 针对接口编程，而不是针对实现编程
     public Director(Builder builder) {
       this.builder = builder;
     }
     public void setBuilder(Builder builder) {
       this.builder = builder;
     }
   
     public void construct() {   // 控制（定义）一个复杂的构建过程
       builder.buildPart1();
       for (int i = 0; i < 5; i++) {   // 提示：如果想在运行过程中替换构建算法，可以考虑结合策略模式。
         builder.buildPart2();
       }
       builder.buildPart3();
     }
   }
   ```

   具体的建造者角色：

   ```java
   /**
    * 此处实现了建造纯文本文档的具体建造者。
    * 可以考虑再实现一个建造HTML文档、XML文档，或者其它什么文档的具体建造者。
    * 这样，就可以使得同样的构建过程可以创建不同的表示
    */
   public class ConcreteBuilder1 extends Builder {
     private StringBuffer buffer = new StringBuffer();//假设 buffer.toString() 就是最终生成的产品
   
     @Override
     public void buildPart1() {//实现构建最终实例需要的所有方法
       buffer.append("Builder1 : Part1\n");
     }
   
     @Override
     public void buildPart2() {
       buffer.append("Builder1 : Part2\n");
     }
   
     @Override
     public void buildPart3() {
       buffer.append("Builder1 : Part3\n");
     }
   
     public String getResult() {//定义获取最终生成实例的方法
       return buffer.toString();
     }
   }
   ```

   客户角色：

   ```java
   public class Client {
     public void testBuilderPattern() {
       ConcreteBuilder1 b1 = new ConcreteBuilder1();//建造者
       Director director = new Director(b1);//监工
       director.construct();//建造实例(监工负责监督，建造者实际建造)
       String result = b1.getResult();//获取最终生成结果
       System.out.printf("the result is :%n%s", result);
     }
   }
   ```

# 5. 原型模式

​	原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

## 5.1 介绍

**意图：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**主要解决：**在运行期建立和删除原型。

**何时使用：** 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、<u>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些</u>。

**如何解决：**利用已有的一个原型对象，快速地生成和原型对象一样的实例。

**关键代码：** 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。

**应用实例：** 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。

**优点：** 1、性能提高。 2、逃避构造函数的约束。

**缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、<u>必须实现 Cloneable 接口</u>。

**使用场景：** 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。

**注意事项：**<u>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流</u>。

## 5.2 实现

我们将创建一个抽象类 *Shape* 和扩展了 *Shape* 类的实体类。下一步是定义类 *ShapeCache*，该类把 shape 对象存储在一个 *Hashtable* 中，并在请求的时候返回它们的克隆。

*PrototypePatternDemo* 类使用 *ShapeCache* 类来获取 *Shape* 对象。

![原型模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201202-prototype-pattern.png)

**步骤 1**

创建一个实现了 *Cloneable* 接口的抽象类。

```java
public abstract class Shape implements Cloneable {

  private String id;
  protected String type;

  abstract void draw();

  public String getType(){
    return type;
  }

  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public Object clone() {
    Object clone = null;
    try {
      clone = super.clone();
    } catch (CloneNotSupportedException e) {
      e.printStackTrace();
    }
    return clone;
  }
}
```

**步骤 2**

创建扩展了上面抽象类的实体类。

```java
public class Rectangle extends Shape {

  public Rectangle(){
    type = "Rectangle";
  }

  @Override
  public void draw() {
    System.out.println("Inside Rectangle::draw() method.");
  }
}
```

```java
public class Square extends Shape {

  public Square(){
    type = "Square";
  }

  @Override
  public void draw() {
    System.out.println("Inside Square::draw() method.");
  }
}
```

```java
public class Circle extends Shape {

  public Circle(){
    type = "Circle";
  }

  @Override
  public void draw() {
    System.out.println("Inside Circle::draw() method.");
  }
}
```

**步骤 3**

创建一个类，从数据库获取实体类，并把它们存储在一个 *Hashtable* 中。

```java
import java.util.Hashtable;

public class ShapeCache {

  private static Hashtable<String, Shape> shapeMap 
    = new Hashtable<String, Shape>();

  public static Shape getShape(String shapeId) {
    Shape cachedShape = shapeMap.get(shapeId);
    return (Shape) cachedShape.clone();
  }

  // 对每种形状都运行数据库查询，并创建该形状
  // shapeMap.put(shapeKey, shape);
  // 例如，我们要添加三种形状
  public static void loadCache() {
    Circle circle = new Circle();
    circle.setId("1");
    shapeMap.put(circle.getId(),circle);

    Square square = new Square();
    square.setId("2");
    shapeMap.put(square.getId(),square);

    Rectangle rectangle = new Rectangle();
    rectangle.setId("3");
    shapeMap.put(rectangle.getId(),rectangle);
  }
}
```

**步骤 4**

*PrototypePatternDemo* 使用 *ShapeCache* 类来获取存储在 *Hashtable* 中的形状的克隆。

```java
public class PrototypePatternDemo {
  public static void main(String[] args) {
    ShapeCache.loadCache();

    Shape clonedShape = (Shape) ShapeCache.getShape("1");
    System.out.println("Shape : " + clonedShape.getType());        

    Shape clonedShape2 = (Shape) ShapeCache.getShape("2");
    System.out.println("Shape : " + clonedShape2.getType());        

    Shape clonedShape3 = (Shape) ShapeCache.getShape("3");
    System.out.println("Shape : " + clonedShape3.getType());        
  }
}
```

**步骤 5**

执行程序，输出结果：

```shell
Shape : Circle
Shape : Square
Shape : Rectangle
```

## 5.3 评论区补充

1. 原型模式的三个角色

   原型模式中有三个登场角色：

   **原型角色**：定义用于复制现有实例来生成新实例的方法；

   ```java
   // 以贴主示例代码为例  
   implements Cloneable   // 1.（抽象类或者接口）实现 java.lang.Cloneable 接口
   public Shape clone();  // 2.定义复制现有实例来生成新实例的方法
   ```

   **具体原型角色**：实现用于复制现有实例来生成新实例的方法

   ```java
   public Shape clone() {// 2.实现复制现有实例来生成新实例的方法（也可以由超类完成）
     Shape clone = null;
     try {
       clone = (Shape) clone();
     } catch (CloneNotSupportedException e) {
       e.printStackTrace();
     }
     return clone;
   }
   ```

   **使用者角色**：维护一个注册表，并提供一个找出正确实例原型的方法。最后，提供一个获取新实例的方法，用来委托复制实例的方法生成新实例。

   ```java
   private static Hashtable<String, Shape> shapeMap = new Hashtable<String, Shape>();//维护一个注册表
   public static void loadCache() {
     Circle circle = new Circle();
     circle.setId("1");
     shapeMap.put(circle.getId(),circle);
   
     Square square = new Square();
     square.setId("2");
     shapeMap.put(square.getId(),square);
   
     Rectangle rectangle = new Rectangle();
     rectangle.setId("3");
     shapeMap.put(rectangle.getId(),rectangle);
   }
   public static Shape getShape(String shapeId) {//提供一个获取新实例的方法
     Shape cachedShape = shapeMap.get(shapeId);//提供一个找出正确实例原型的方法
     return (Shape) cachedShape.clone();//委托复制实例的方法生成新实例。
   }
   ```

# 6. 适配器模式

​	适配器模式（Adapter Pattern）是作为<u>两个不兼容的接口之间的桥梁</u>。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

​	这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，<u>读卡器是作为内存卡和笔记本之间的适配器</u>。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

​	我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。

## 6.1 介绍

**意图：**将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**主要解决：**主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

**何时使用：** 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

**如何解决：**继承或<u>依赖（推荐）</u>。

**关键代码：**适配器继承或依赖已有的对象，实现想要的目标接口。

**应用实例：** 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、<u>JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式</u>。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。

**优点：** 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。

**缺点：** 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

**使用场景：**<u>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式</u>。

**注意事项：**<u>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题</u>。

## 6.2 实现

​	我们有一个 *MediaPlayer* 接口和一个实现了 *MediaPlayer* 接口的实体类 *AudioPlayer*。默认情况下，*AudioPlayer* 可以播放 mp3 格式的音频文件。

​	我们还有另一个接口 *AdvancedMediaPlayer* 和实现了 *AdvancedMediaPlayer* 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。

​	我们想要让 *AudioPlayer* 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 *MediaPlayer* 接口的适配器类 *MediaAdapter*，并使用 *AdvancedMediaPlayer* 对象来播放所需的格式。

​	*AudioPlayer* 使用适配器类 *MediaAdapter* 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。*AdapterPatternDemo* 类使用 *AudioPlayer* 类来播放各种格式。

![适配器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20210223-adapter.png)

**步骤 1**

为媒体播放器和更高级的媒体播放器创建接口。

```java
public interface MediaPlayer {
  public void play(String audioType, String fileName);
}
```

```java
public interface AdvancedMediaPlayer { 
  public void playVlc(String fileName);
  public void playMp4(String fileName);
}
```

**步骤 2**

创建实现了 *AdvancedMediaPlayer* 接口的实体类。

```java
public class VlcPlayer implements AdvancedMediaPlayer{
  @Override
  public void playVlc(String fileName) {
    System.out.println("Playing vlc file. Name: "+ fileName);      
  }

  @Override
  public void playMp4(String fileName) {
    //什么也不做
  }
}
```

```java
public class Mp4Player implements AdvancedMediaPlayer{

  @Override
  public void playVlc(String fileName) {
    //什么也不做
  }

  @Override
  public void playMp4(String fileName) {
    System.out.println("Playing mp4 file. Name: "+ fileName);      
  }
}
```

**步骤 3**

创建实现了 *MediaPlayer* 接口的适配器类。

```java
public class MediaAdapter implements MediaPlayer {

  AdvancedMediaPlayer advancedMusicPlayer;

  public MediaAdapter(String audioType){
    if(audioType.equalsIgnoreCase("vlc") ){
      advancedMusicPlayer = new VlcPlayer();       
    } else if (audioType.equalsIgnoreCase("mp4")){
      advancedMusicPlayer = new Mp4Player();
    }  
  }

  @Override
  public void play(String audioType, String fileName) {
    if(audioType.equalsIgnoreCase("vlc")){
      advancedMusicPlayer.playVlc(fileName);
    }else if(audioType.equalsIgnoreCase("mp4")){
      advancedMusicPlayer.playMp4(fileName);
    }
  }
}
```

**步骤 4**

创建实现了 *MediaPlayer* 接口的实体类。

```java
public class AudioPlayer implements MediaPlayer {
  MediaAdapter mediaAdapter; 

  @Override
  public void play(String audioType, String fileName) {    

    //播放 mp3 音乐文件的内置支持
    if(audioType.equalsIgnoreCase("mp3")){
      System.out.println("Playing mp3 file. Name: "+ fileName);         
    } 
    //mediaAdapter 提供了播放其他文件格式的支持
    else if(audioType.equalsIgnoreCase("vlc") 
            || audioType.equalsIgnoreCase("mp4")){
      mediaAdapter = new MediaAdapter(audioType);
      mediaAdapter.play(audioType, fileName);
    }
    else{
      System.out.println("Invalid media. "+
                         audioType + " format not supported");
    }
  }   
}
```

**步骤 5**

使用 AudioPlayer 来播放不同类型的音频格式。

```java
public class AdapterPatternDemo {
  public static void main(String[] args) {
    AudioPlayer audioPlayer = new AudioPlayer();

    audioPlayer.play("mp3", "beyond the horizon.mp3");
    audioPlayer.play("mp4", "alone.mp4");
    audioPlayer.play("vlc", "far far away.vlc");
    audioPlayer.play("avi", "mind me.avi");
  }
}
```

**步骤 6**

执行程序，输出结果：

```shell
Playing mp3 file. Name: beyond the horizon.mp3
Playing mp4 file. Name: alone.mp4
Playing vlc file. Name: far far away.vlc
Invalid media. avi format not supported
```

## 6.3 * 评论区补充

1. 分享一个例子：笔记本通过读卡去读取TF卡；

   + **先模拟计算机读取SD卡**

     1. 先创建一个SD卡的接口：

        ```java
        public interface SDCard {
          //读取SD卡方法
          String readSD();
          //写入SD卡功能
          int writeSD(String msg);
        }
        ```

     2. 创建SD卡接口的实现类，模拟SD卡的功能：

        ```java
        public class SDCardImpl implements SDCard {
          @Override    
          public String readSD() {
            String msg = "sdcard read a msg :hello word SD";
            return msg;  
          }
          @Override  
          public int writeSD(String msg) {      
            System.out.println("sd card write msg : " + msg);    
            return 1;   
          }
        }
        ```

     3. 创建计算机接口，计算机提供读取SD卡方法：

        ```java
        public interface Computer {    
          String readSD(SDCard sdCard);
        }
        ```

     4. 创建一个计算机实例，实现计算机接口，并实现其读取SD卡方法：

        ```java
        public class ThinkpadComputer implements Computer {
          @Override    
          public String readSD(SDCard sdCard) {        
            if(sdCard == null)throw new NullPointerException("sd card null");        
            return sdCard.readSD();    
          }
        }
        ```

     5. 这时候就可以模拟计算机读取SD卡功能：

        ```java
        public class ComputerReadDemo {    
          public static void main(String[] args) {        
            Computer computer = new ThinkpadComputer();        
            SDCard sdCard = new SDCardImpl();       
            System.out.println(computer.readSD(sdCard));    
          }
        }
        ```

   + **接下来在不改变计算机读取SD卡接口的情况下，通过适配器模式读取TF卡：**

     1. 创建TF卡接口：

        ```java
        public interface TFCard {    
          String readTF();    
          int writeTF(String msg);
        }
        ```

     2. 创建TF卡实例：

        ```java
        public class TFCardImpl implements TFCard {    
          @Override    
          public String readTF() {        
            String msg ="tf card reade msg : hello word tf card";        
            return msg;    
          }    
          @Override    
          public int writeTF(String msg) {        
            System.out.println("tf card write a msg : " + msg);        
            return 1;    
          }
        }
        ```

     3. 创建SD适配TF （也可以说是SD兼容TF，相当于读卡器）：

        实现SDCard接口，并将要适配的对象作为适配器的属性引入。

        ```java
        public class SDAdapterTF implements SDCard {    
          private TFCard tfCard;    
          public SDAdapterTF(TFCard tfCard) {        
            this.tfCard = tfCard;    
          }    
          @Override    
          public String readSD() {        
            System.out.println("adapter read tf card ");        
            return tfCard.readTF();    
          }    
          @Override    
          public int writeSD(String msg) {        
            System.out.println("adapter write tf card");        
            return tfCard.writeTF(msg);    
          }
        }
        ```

     4. 通过上面的例子测试计算机通过SD读卡器读取TF卡：

        ```java
        public class ComputerReadDemo {    
          public static void main(String[] args) {        
            Computer computer = new ThinkpadComputer();        
            SDCard sdCard = new SDCardImpl();        
            System.out.println(computer.readSD(sdCard));        
            System.out.println("====================================");        
            TFCard tfCard = new TFCardImpl();        
            SDCard tfCardAdapterSD = new SDAdapterTF(tfCard);        
            System.out.println(computer.readSD(tfCardAdapterSD));    
          }
        }
        ```

     5. 输出：

        ```shell
        sdcard read a msg :hello word SD
        ====================================
        adapter read tf card 
        tf card reade msg : hello word tf card
        ```

     ​	在这种模式下，计算机并不需要知道具体是什么卡，只需要负责操作接口即可，具体操作的什么类，由适配器决定。

# 7. 桥接模式

​	桥接（Bridge）是用于**把抽象化与实现化解耦**，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

​	这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

​	我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。

## 7.1 介绍

**意图：**将抽象部分与实现部分分离，使它们都可以独立的变化。

**主要解决：**在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

**何时使用：**<u>实现系统可能有多个角度分类，每一种角度都可能变化</u>。

**如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。

**关键代码：**抽象类依赖实现类。

**应用实例：** 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。

**优点：** 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。

**缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

**使用场景：** 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

**注意事项：**<u>对于两个独立变化的维度，使用桥接模式再适合不过了</u>。

## 7.2 实现

​	我们有一个作为桥接实现的 *DrawAPI* 接口和实现了 *DrawAPI* 接口的实体类 *RedCircle*、*GreenCircle*。*Shape* 是一个抽象类，将使用 *DrawAPI* 的对象。*BridgePatternDemo* 类使用 *Shape* 类来画出不同颜色的圆。

![桥接模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-bridge.svg)

**步骤 1**

创建桥接实现接口。

```java
public interface DrawAPI {
  public void drawCircle(int radius, int x, int y);
}
```

**步骤 2**

创建实现了 *DrawAPI* 接口的实体桥接实现类。

```java
public class RedCircle implements DrawAPI {
  @Override
  public void drawCircle(int radius, int x, int y) {
    System.out.println("Drawing Circle[ color: red, radius: "
                       + radius +", x: " +x+", "+ y +"]");
  }
}
```

```java
public class GreenCircle implements DrawAPI {
  @Override
  public void drawCircle(int radius, int x, int y) {
    System.out.println("Drawing Circle[ color: green, radius: "
                       + radius +", x: " +x+", "+ y +"]");
  }
}
```

**步骤 3**

使用 *DrawAPI* 接口创建抽象类 *Shape*。

```java
public abstract class Shape {
  protected DrawAPI drawAPI;
  protected Shape(DrawAPI drawAPI){
    this.drawAPI = drawAPI;
  }
  public abstract void draw();  
}
```

**步骤 4**

创建实现了 *Shape* 抽象类的实体类。

```java
public class Circle extends Shape {
  private int x, y, radius;

  public Circle(int x, int y, int radius, DrawAPI drawAPI) {
    super(drawAPI);
    this.x = x;  
    this.y = y;  
    this.radius = radius;
  }

  public void draw() {
    drawAPI.drawCircle(radius,x,y);
  }
}
```

**步骤 5**

使用 *Shape* 和 *DrawAPI* 类画出不同颜色的圆。

```java
public class BridgePatternDemo {
  public static void main(String[] args) {
    Shape redCircle = new Circle(100,100, 10, new RedCircle());
    Shape greenCircle = new Circle(100,100, 10, new GreenCircle());

    redCircle.draw();
    greenCircle.draw();
  }
}
```

**步骤 6**

执行程序，输出结果：

```
Drawing Circle[ color: red, radius: 10, x: 100, 100]
Drawing Circle[  color: green, radius: 10, x: 100, 100]
```

## 7.3 相关文章

> + [设计模式读书笔记-----桥接模式 ](https://www.cnblogs.com/chenssy/p/3317866.html) <= 下面只截取了部分内容

​	开始学java的时候老师讲到继承的时候，总是喜欢用一个例子来讲解，那就是画图，这里有一个画笔，可以画正方形、长方形、圆形（这个大家都知道怎么做吧，我就不解释了）。但是现在我们需要给这些形状进行上色，这里有三种颜色：白色、灰色、黑色。这里我们可以画出3*3=9中图形：白色正方形、白色长方形、白色圆形。。。。。。到这里了我们几乎到知道了这里存在两种解决方案：

+ 方案一：为每种形状都提供各种颜色的版本。

+ 方案二：根据实际需要对颜色和形状进行组合。

​	我们我们采用方案一来实现的话，我们是不是也可以这样来理解呢？为每种颜色都提供各种形状的版本呢？这个是完全的可以的。如下：

[![1111](https://images0.cnblogs.com/blog/381060/201309/12212904-5e7bdaf5860647ea85bd1259c38d9da9.png)](https://images0.cnblogs.com/blog/381060/201309/12212904-68f2e220b140481ba36b304f0b6f129b.png)

 

​	对于中两个图形，我们都会很清楚这样一个问题：加入我们添加椭圆，我们是不是又要增加三种颜色呢？假如我们在增加一个绿色，我们就要增加其四种形状了，继续加。继续加……每次增加都会增加若干个类(如果增加颜色则会增加形状个数个类，若增加形状则会增加颜色个数个类)，这样的情况我想每个程序员都不会想要吧！那么我们看方案二。

​	方案二所提供的就是解决方法是：提供两个父类一个是颜色、一个形状，颜色父类和形状父类两个类都包含了相应的子类，然后根据需要对颜色和形状进行组合。

[![33333](https://images0.cnblogs.com/blog/381060/201309/12212905-282280c2326b4864acb1dc87dd3c3d84.jpg)](https://images0.cnblogs.com/blog/381060/201309/12212905-60051681d812432a947e145508b66161.jpg)

 

​	对于有几个变化的维度，我们一般采用方案二来实现，这样除了减少系统中的类个数，也利于系统扩展。对于方案二的应用我们称之为桥接模式。

[![4444](https://images0.cnblogs.com/blog/381060/201309/12212906-694e391dae0e4553982b1a80222f1b72.png)](https://images0.cnblogs.com/blog/381060/201309/12212905-3f7da9d436f6426d8d4d166d2b427670.png)

## 7.4 * 评论区补充

1. 桥接模式：Bridge Pattern

   将抽象和实现放在两个不同的类层次中，使它们可以独立地变化。——《Head First 设计模式》

   **将类的功能层次结构和实现层次结构相分离**，**使二者能够独立地变化**，**并在两者之间搭建桥梁，实现桥接**。—— 《图解设计模式》

   类的功能层次结构：父类具有基本功能，在子类中增加新的功能；

   类的实现层次结构：父类通过声明抽象方法来定义接口，子类通过实现具体方法来实现接口；

   桥接模式中有四个角色：

   **抽象化角色**：使用实现者角色提供的接口来定义基本功能接口。

   持有实现者角色，并在功能接口中委托给它，起到搭建桥梁的作用；

   注意，抽象化角色并不是指它就是一个抽象类，而是指抽象了实现。

   **改善后的抽象化角色**：作为抽象化角色的子类，增加新的功能，也就是增加新的接口（方法）；与其构成类的功能层次结构；

   **实现者角色**：提供了用于抽象化角色的接口；它是一个抽象类或者接口。

   **具体的实现者角色**：作为实现者角色的子类，通过实现具体方法来实现接口；与其构成类的实现层次结构。

   **如果抽象和实现两者做不到独立地变化，就不算桥接模式**。

2. 示例中的桥梁

   桥接模式中，具体的实现类放在作为“桥梁”的接口中实现，而“桥梁”接口中只有实现功能的抽象方法；具体实现类是继承“桥梁”，而不直接继承实现类的抽象类，抽象类与具体的实现类在结构上是相互独立的，两者的相互变化并不会影响到彼此，只要“桥梁”没变，两者的变化并不会影响到彼此。

   <u>就以上教程的实例程序来说，具体的实现是RedCircle、GreenCircle，它们的抽象类为Shape，按一般逻辑来说，我们是直接继承Shape来创建不同的具体对象，但桥接模式中是通过“桥梁”DrawAPI建立抽象与具体实现之间的联系，调用DrawAPI中的方法来具体实现</u>。

# 8. 过滤器模式

# 9. 组合模式

​	组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。<u>组合模式依据树形结构来组合对象，用来表示部分以及整体层次</u>。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

​	<u>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</u>

​	我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。

## 9.1 介绍

**意图：**将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

**主要解决：**它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

**何时使用：** 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

**如何解决：**<u>树枝和叶子实现统一接口，树枝内部组合该接口</u>。

**关键代码：**<u>树枝内部组合该接口，并且含有内部属性 List，里面放 Component</u>。

**应用实例：** 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。

**优点：** 1、高层模块调用简单。 2、节点自由增加。

**缺点：**<u>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则</u>。

**使用场景：**部分、整体场景，如树形菜单，文件、文件夹的管理。

**注意事项：**定义时为具体类。

## 9.2 实现

我们有一个类 *Employee*，该类被当作组合模型类。*CompositePatternDemo* 类使用 *Employee* 类来添加部门层次结构，并打印所有员工。

![组合模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-composite.svg)

**步骤 1**

创建 *Employee* 类，该类带有 *Employee* 对象的列表。

```java
import java.util.ArrayList;
import java.util.List;

public class Employee {
  private String name;
  private String dept;
  private int salary;
  private List<Employee> subordinates;

  //构造函数
  public Employee(String name,String dept, int sal) {
    this.name = name;
    this.dept = dept;
    this.salary = sal;
    subordinates = new ArrayList<Employee>();
  }

  public void add(Employee e) {
    subordinates.add(e);
  }

  public void remove(Employee e) {
    subordinates.remove(e);
  }

  public List<Employee> getSubordinates(){
    return subordinates;
  }

  public String toString(){
    return ("Employee :[ Name : "+ name 
            +", dept : "+ dept + ", salary :"
            + salary+" ]");
  }   
}
```

**步骤 2**

使用 *Employee* 类来创建和打印员工的层次结构。

```java
public class CompositePatternDemo {
  public static void main(String[] args) {
    Employee CEO = new Employee("John","CEO", 30000);

    Employee headSales = new Employee("Robert","Head Sales", 20000);

    Employee headMarketing = new Employee("Michel","Head Marketing", 20000);

    Employee clerk1 = new Employee("Laura","Marketing", 10000);
    Employee clerk2 = new Employee("Bob","Marketing", 10000);

    Employee salesExecutive1 = new Employee("Richard","Sales", 10000);
    Employee salesExecutive2 = new Employee("Rob","Sales", 10000);

    CEO.add(headSales);
    CEO.add(headMarketing);

    headSales.add(salesExecutive1);
    headSales.add(salesExecutive2);

    headMarketing.add(clerk1);
    headMarketing.add(clerk2);

    //打印该组织的所有员工
    System.out.println(CEO); 
    for (Employee headEmployee : CEO.getSubordinates()) {
      System.out.println(headEmployee);
      for (Employee employee : headEmployee.getSubordinates()) {
        System.out.println(employee);
      }
    }        
  }
}
```

**步骤 3**

执行程序，输出结果为：

```java
Employee :[ Name : John, dept : CEO, salary :30000 ]
Employee :[ Name : Robert, dept : Head Sales, salary :20000 ]
Employee :[ Name : Richard, dept : Sales, salary :10000 ]
Employee :[ Name : Rob, dept : Sales, salary :10000 ]
Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ]
Employee :[ Name : Laura, dept : Marketing, salary :10000 ]
Employee :[ Name : Bob, dept : Marketing, salary :10000 ]
```

## 9.3 * 评论区补充

1. 组合模式讲解。

   1. 组合模式，就是在一个对象中包含其他对象，这些被包含的对象可能是终点对象（不再包含别的对象），也有可能是非终点对象（其内部还包含其他对象，或叫组对象），我们将对象称为节点，即一个根节点包含许多子节点，这些子节点有的不再包含子节点，而有的仍然包含子节点，以此类推。

   2. 所谓组合模式，其实说的是对象包含对象的问题，通过组合的方式（在对象内部引用对象）来进行布局，我认为这种组合是区别于继承的，而另一层含义是指树形结构子节点的抽象（将叶子节点与数枝节点抽象为子节点），区别于普通的分别定义叶子节点与数枝节点的方式。

   **更多内容请查看：[Java 设计模式之组合模式及应用场景](https://www.runoob.com/w3cnote/java-composite-pattern-2.html)**

# 10. * 装饰器模式

​	装饰器模式（Decorator Pattern）<u>允许向一个现有的对象添加新的功能，同时又不改变其结构</u>。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

​	这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

​	我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。

## 10.1 介绍

**意图：**<u>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活</u>。

**主要解决：**一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。

**何时使用：**在不想增加很多子类的情况下扩展类。

**如何解决：**将具体功能职责划分，同时继承装饰者模式。

**关键代码：** 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。

**应用实例：** 1、孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。

**优点：**<u>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能</u>。

**缺点：**多层装饰比较复杂。

**使用场景：** 1、扩展一个类的功能。 2、动态增加功能，动态撤销。

**注意事项：**<u>可代替继承</u>。

## 10.2 实现

我们将创建一个 *Shape* 接口和实现了 *Shape* 接口的实体类。然后我们创建一个实现了 *Shape* 接口的抽象装饰类 *ShapeDecorator*，并把 *Shape* 对象作为它的实例变量。

*RedShapeDecorator* 是实现了 *ShapeDecorator* 的实体类。

*DecoratorPatternDemo* 类使用 *RedShapeDecorator* 来装饰 *Shape* 对象。

![装饰器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20210420-decorator-1-decorator-decorator.svg)

**步骤 1**

创建一个接口：

```java
public interface Shape {
  void draw();
}
```

**步骤 2**

创建实现接口的实体类。

```java
public class Rectangle implements Shape {
  @Override
  public void draw() {
    System.out.println("Shape: Rectangle");
  }
}
```

```java
public class Circle implements Shape {
  @Override
  public void draw() {
    System.out.println("Shape: Circle");
  }
}
```

**步骤 3**

创建实现了 *Shape* 接口的抽象装饰类。

```java
public abstract class ShapeDecorator implements Shape {
  protected Shape decoratedShape;

  public ShapeDecorator(Shape decoratedShape){
    this.decoratedShape = decoratedShape;
  }

  public void draw(){
    decoratedShape.draw();
  }  
}
```

**步骤 4**

创建扩展了 *ShapeDecorator* 类的实体装饰类。

```java
public class RedShapeDecorator extends ShapeDecorator {

  public RedShapeDecorator(Shape decoratedShape) {
    super(decoratedShape);     
  }

  @Override
  public void draw() {
    decoratedShape.draw();         
    setRedBorder(decoratedShape);
  }

  private void setRedBorder(Shape decoratedShape){
    System.out.println("Border Color: Red");
  }
}
```

**步骤 5**

使用 *RedShapeDecorator* 来装饰 *Shape* 对象。

```java
public class DecoratorPatternDemo {
  public static void main(String[] args) {

    Shape circle = new Circle();
    ShapeDecorator redCircle = new RedShapeDecorator(new Circle());
    ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());
    //Shape redCircle = new RedShapeDecorator(new Circle());
    //Shape redRectangle = new RedShapeDecorator(new Rectangle());
    System.out.println("Circle with normal border");
    circle.draw();

    System.out.println("\nCircle of red border");
    redCircle.draw();

    System.out.println("\nRectangle of red border");
    redRectangle.draw();
  }
}
```

**步骤 6**

执行程序，输出结果：

```shell
Circle with normal border
Shape: Circle

Circle of red border
Shape: Circle
Border Color: Red

Rectangle of red border
Shape: Rectangle
Border Color: Red
```

## 10.3 * 评论区补充

1. 一个更易理解的实例：

   装饰模式为已有类动态附加额外的功能就像LOL、王者荣耀等类Dota游戏中，英雄升级一样。每次英雄升级都会附加一个额外技能点学习技能。具体的英雄就是ConcreteComponent，技能栏就是装饰器Decorator，每个技能就是ConcreteDecorator；

   ```java
   //Component 英雄接口 
   public interface Hero {
     //学习技能
     void learnSkills();
   }
   //ConcreteComponent 具体英雄盲僧
   public class BlindMonk implements Hero {
   
     private String name;
   
     public BlindMonk(String name) {
       this.name = name;
     }
   
     @Override
     public void learnSkills() {
       System.out.println(name + "学习了以上技能！");
     }
   }
   //Decorator 技能栏
   public class Skills implements Hero{
   
     //持有一个英雄对象接口
     private Hero hero;
   
     public Skills(Hero hero) {
       this.hero = hero;
     }
   
     @Override
     public void learnSkills() {
       if(hero != null)
         hero.learnSkills();
     }    
   }
   //ConreteDecorator 技能：Q
   public class Skill_Q extends Skills{
   
     private String skillName;
   
     public Skill_Q(Hero hero,String skillName) {
       super(hero);
       this.skillName = skillName;
     }
   
     @Override
     public void learnSkills() {
       System.out.println("学习了技能Q:" +skillName);
       super.learnSkills();
     }
   }
   //ConreteDecorator 技能：W
   public class Skill_W extends Skills{
   
     private String skillName;
   
     public Skill_W(Hero hero,String skillName) {
       super(hero);
       this.skillName = skillName;
     }
   
     @Override
     public void learnSkills() {
       System.out.println("学习了技能W:" + skillName);
       super.learnSkills();
     }
   }
   //ConreteDecorator 技能：E
   public class Skill_E extends Skills{
   
     private String skillName;
   
     public Skill_E(Hero hero,String skillName) {
       super(hero);
       this.skillName = skillName;
     }
   
     @Override
     public void learnSkills() {
       System.out.println("学习了技能E:"+skillName);
       super.learnSkills();
     }
   }
   //ConreteDecorator 技能：R
   public class Skill_R extends Skills{    
   
     private String skillName;
   
     public Skill_R(Hero hero,String skillName) {
       super(hero);
       this.skillName = skillName;
     }
   
     @Override
     public void learnSkills() {
       System.out.println("学习了技能R:" +skillName );
       super.learnSkills();
     }
   }
   //客户端：召唤师
   public class Player {
     public static void main(String[] args) {
       //选择英雄
       Hero hero = new BlindMonk("李青");
   
       Skills skills = new Skills(hero);
       Skills r = new Skill_R(skills,"猛龙摆尾");
       Skills e = new Skill_E(r,"天雷破/摧筋断骨");
       Skills w = new Skill_W(e,"金钟罩/铁布衫");
       Skills q = new Skill_Q(w,"天音波/回音击");
       //学习技能
       q.learnSkills();
     }
   }
   ```

   输出：

   ```shell
   学习了技能Q:天音波/回音击
   学习了技能W:金钟罩/铁布衫
   学习了技能E:天雷破/摧筋断骨
   学习了技能R:猛龙摆尾
   李青学习了以上技能！
   ```

# 11. 外观模式

​	外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

​	这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

## 11.1 介绍

**意图：**为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

**主要解决：**降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。

**何时使用：** 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。

**如何解决：**客户端不与系统耦合，外观类与系统耦合。

**关键代码：**在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。

**应用实例：** 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。

**优点：** 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。

**缺点：**不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。

**使用场景：** 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。

**注意事项：**在层次化结构中，可以使用外观模式定义系统中每一层的入口。

## 11.2 实现

​	我们将创建一个 *Shape* 接口和实现了 *Shape* 接口的实体类。下一步是定义一个外观类 *ShapeMaker*。

​	*ShapeMaker* 类使用实体类来代表用户对这些类的调用。*FacadePatternDemo* 类使用 *ShapeMaker* 类来显示结果。

![外观模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-facade.svg)

**步骤 1**

创建一个接口。

```java
public interface Shape {
   void draw();
}
```

**步骤 2**

创建实现接口的实体类。

```java
public class Rectangle implements Shape {
  @Override
  public void draw() {
    System.out.println("Rectangle::draw()");
  }
}
```

```java
public class Square implements Shape {
  @Override
  public void draw() {
    System.out.println("Square::draw()");
  }
}
```

```java
public class Circle implements Shape {
  @Override
  public void draw() {
    System.out.println("Circle::draw()");
  }
}
```

**步骤 3**

创建一个外观类。

```java
public class ShapeMaker {
  private Shape circle;
  private Shape rectangle;
  private Shape square;

  public ShapeMaker() {
    circle = new Circle();
    rectangle = new Rectangle();
    square = new Square();
  }

  public void drawCircle(){
    circle.draw();
  }
  public void drawRectangle(){
    rectangle.draw();
  }
  public void drawSquare(){
    square.draw();
  }
}
```

**步骤 4**

使用该外观类画出各种类型的形状。

```java
public class FacadePatternDemo {
  public static void main(String[] args) {
    ShapeMaker shapeMaker = new ShapeMaker();

    shapeMaker.drawCircle();
    shapeMaker.drawRectangle();
    shapeMaker.drawSquare();      
  }
}
```

**步骤 5**

执行程序，输出结果：

```shell
Circle::draw()
Rectangle::draw()
Square::draw()
```

## 11.3 评论区补充

1. 举例子

   感觉电脑的例子更形象：

   电脑整机是 CPU、内存、硬盘的外观。有了外观以后，启动电脑和关闭电脑都简化了。

   直接 new 一个电脑。

   在 new 电脑的同时把 cpu、内存、硬盘都初始化好并且接好线。

   对外暴露方法（启动电脑，关闭电脑）。

   启动电脑（按一下电源键）：启动CPU、启动内存、启动硬盘

   关闭电脑（按一下电源键）：关闭硬盘、关闭内存、关闭CPU

   **更多参考内容**

   -  [Java 设计模式 – 外观模式](https://www.runoob.com/w3cnote/facade-pattern-2.html)
   -  [JAVA设计模式之门面模式 - 医院实例](https://www.runoob.com/w3cnote/facade-pattern-3.html)

# 12. * 享元模式

​	享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

​	享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 *Circle* 对象。

## 12.1 介绍

**意图：**运用共享技术有效地支持大量细粒度的对象。

**主要解决：**<u>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建</u>。

**何时使用：** 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。

**如何解决：**用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。

**关键代码：**用 HashMap 存储这些对象。

**应用实例：** 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。

**优点：**大大减少对象的创建，降低系统的内存，使效率提高。

**缺点：**提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。

**使用场景：** 1、系统有大量相似对象。 2、<u>需要缓冲池的场景</u>。

**注意事项：** 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。

## 12.2 实现

![享元模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-fiyweight.svg)

**步骤 1**

创建一个接口。

```java
public interface Shape {
  void draw();
}
```

**步骤 2**

创建实现接口的实体类。

```java
public class Circle implements Shape {
  private String color;
  private int x;
  private int y;
  private int radius;

  public Circle(String color){
    this.color = color;     
  }

  public void setX(int x) {
    this.x = x;
  }

  public void setY(int y) {
    this.y = y;
  }

  public void setRadius(int radius) {
    this.radius = radius;
  }

  @Override
  public void draw() {
    System.out.println("Circle: Draw() [Color : " + color 
                       +", x : " + x +", y :" + y +", radius :" + radius);
  }
}
```

**步骤 3**

创建一个工厂，生成基于给定信息的实体类的对象。

```java
import java.util.HashMap;

public class ShapeFactory {
  private static final HashMap<String, Shape> circleMap = new HashMap<>();

  public static Shape getCircle(String color) {
    Circle circle = (Circle)circleMap.get(color);

    if(circle == null) {
      circle = new Circle(color);
      circleMap.put(color, circle);
      System.out.println("Creating circle of color : " + color);
    }
    return circle;
  }
}
```

**步骤 4**

使用该工厂，通过传递颜色信息来获取实体类的对象。

```java
public class FlyweightPatternDemo {
  private static final String colors[] = 
  { "Red", "Green", "Blue", "White", "Black" };
  public static void main(String[] args) {

    for(int i=0; i < 20; ++i) {
      Circle circle = 
        (Circle)ShapeFactory.getCircle(getRandomColor());
      circle.setX(getRandomX());
      circle.setY(getRandomY());
      circle.setRadius(100);
      circle.draw();
    }
  }
  private static String getRandomColor() {
    return colors[(int)(Math.random()*colors.length)];
  }
  private static int getRandomX() {
    return (int)(Math.random()*100 );
  }
  private static int getRandomY() {
    return (int)(Math.random()*100);
  }
}
```

**步骤 5**

执行程序，输出结果：

```shell
Creating circle of color : Black
Circle: Draw() [Color : Black, x : 36, y :71, radius :100
Creating circle of color : Green
Circle: Draw() [Color : Green, x : 27, y :27, radius :100
Creating circle of color : White
Circle: Draw() [Color : White, x : 64, y :10, radius :100
Creating circle of color : Red
Circle: Draw() [Color : Red, x : 15, y :44, radius :100
Circle: Draw() [Color : Green, x : 19, y :10, radius :100
Circle: Draw() [Color : Green, x : 94, y :32, radius :100
Circle: Draw() [Color : White, x : 69, y :98, radius :100
Creating circle of color : Blue
Circle: Draw() [Color : Blue, x : 13, y :4, radius :100
Circle: Draw() [Color : Green, x : 21, y :21, radius :100
Circle: Draw() [Color : Blue, x : 55, y :86, radius :100
Circle: Draw() [Color : White, x : 90, y :70, radius :100
Circle: Draw() [Color : Green, x : 78, y :3, radius :100
Circle: Draw() [Color : Green, x : 64, y :89, radius :100
Circle: Draw() [Color : Blue, x : 3, y :91, radius :100
Circle: Draw() [Color : Blue, x : 62, y :82, radius :100
Circle: Draw() [Color : Green, x : 97, y :61, radius :100
Circle: Draw() [Color : Green, x : 86, y :12, radius :100
Circle: Draw() [Color : Green, x : 38, y :93, radius :100
Circle: Draw() [Color : Red, x : 76, y :82, radius :100
Circle: Draw() [Color : Blue, x : 95, y :82, radius :100
```

## 12.3 评论区补充

1. 享元模式介绍

   ​	享元模式，换句话说就是共享对象，在某些对象需要重复创建，且最终只需要得到单一结果的情况下使用。因为此种模式是利用先前创建的已有对象，通过某种规则去判断当前所需对象是否可以利用原有对象做相应修改后得到想要的效果，如以上教程的实例，创建了20个不同效果的圆，但相同颜色的圆只需要创建一次便可，相同颜色的只需要引用原有对象，改变其坐标值便可。此种模式下，同一颜色的圆虽然位置不同，但其地址都是同一个，所以说此模式适用于结果注重单一结果的情况。

   ​	举一个简单例子，一个游戏中有不同的英雄角色，同一类型的角色也有不同属性的英雄，如刺客类型的英雄有很多个，按此种模式设计，利用英雄所属类型去引用原有同一类型的英雄实例，然后对其相应属性进行修改，便可得到最终想得到的最新英雄；比如说你创建了第一个刺客型英雄，然后需要设计第二个刺客型英雄，你利用第一个英雄改变属性得到第二个刺客英雄，最新的刺客英雄是诞生了，但第一个刺客英雄的属性也随之变得与第二个相同，这种情况显然是不可以的。

# 13. * 代理模式

​	在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。

​	在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

## 13.1 介绍

**意图：**为其他对象提供一种代理以控制对这个对象的访问。

**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

**何时使用：**想在访问一个类时做一些控制。

**如何解决：**增加中间层。

**关键代码：**实现与被代理类组合。

**应用实例：** 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。

**优点：** 1、职责清晰。 2、高扩展性。 3、智能化。

**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

**使用场景：**<u>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</u>

**注意事项：** <u>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</u>

## 13.2 实现

​	我们将创建一个 *Image* 接口和实现了 *Image* 接口的实体类。*ProxyImage* 是一个代理类，减少 *RealImage* 对象加载的内存占用。

*ProxyPatternDemo* 类使用 *ProxyImage* 来获取要加载的 *Image* 对象，并按照需求进行显示。

![代理模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-proxy.svg)

**步骤 1**

创建一个接口。

```java
public interface Image {
  void display();
}
```

**步骤 2**

创建实现接口的实体类。

```java
public class RealImage implements Image {

  private String fileName;

  public RealImage(String fileName){
    this.fileName = fileName;
    loadFromDisk(fileName);
  }

  @Override
  public void display() {
    System.out.println("Displaying " + fileName);
  }

  private void loadFromDisk(String fileName){
    System.out.println("Loading " + fileName);
  }
}
```

```java
public class ProxyImage implements Image{

  private RealImage realImage;
  private String fileName;

  public ProxyImage(String fileName){
    this.fileName = fileName;
  }

  @Override
  public void display() {
    if(realImage == null){
      realImage = new RealImage(fileName);
    }
    realImage.display();
  }
}
```

**步骤 3**

当被请求时，使用 *ProxyImage* 来获取 *RealImage* 类的对象。

```java
public class ProxyPatternDemo {

  public static void main(String[] args) {
    Image image = new ProxyImage("test_10mb.jpg");

    // 图像将从磁盘加载
    image.display(); 
    System.out.println("");
    // 图像不需要从磁盘加载
    image.display();  
  }
}
```

**步骤 4**

执行程序，输出结果：

```shell
Loading test_10mb.jpg
Displaying test_10mb.jpg

Displaying test_10mb.jpg
```

## 13.3 * 评论区补充

1. JDK 自带的动态代理

   +  java.lang.reflect.Proxy：生成动态代理类和对象；
   +  java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现对真实角色的代理访问。

   每次通过 Proxy 生成的代理类对象都要指定对应的处理器对象。

   代码：

   1. 接口：Subject.java

      ```java
      public interface Subject {
        public int sellBooks();
        public String speak();
      }
      ```

   2. 真实对象：RealSubject.java

      ```java
      public class RealSubject implements Subject{
        @Override
        public int sellBooks() {
          System.out.println("卖书");
          return 1 ;
        }
        @Override
        public String speak() {
          System.out.println("说话");
          return "张三";
        }
      }
      ```

   3. 处理器对象：MyInvocationHandler.java

      ```java
      public class MyInvocationHandler implements InvocationHandler {
        /**
           * 因为需要处理真实角色，所以要把真实角色传进来
           */
        Subject realSubject ;
      
        public MyInvocationHandler(Subject realSubject) {
          this.realSubject = realSubject;
        }
      
        /**
           *
           * @param proxy    代理类
           * @param method    正在调用的方法
           * @param args      方法的参数
           * @return
           * @throws Throwable
           */
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          System.out.println("调用代理类");
          if(method.getName().equals("sellBooks")){
            int invoke = (int)method.invoke(realSubject, args);
            System.out.println("调用的是卖书的方法");
            return invoke ;
          }else {
            String string = (String) method.invoke(realSubject,args) ;
            System.out.println("调用的是说话的方法");
            return  string ;
          }
        }
      }
      ```

   4. 调用端：Main.java

      ```java
      public class Client {
        public static void main(String[] args) {
          //真实对象
          Subject realSubject =  new RealSubject();
      
          MyInvocationHandler myInvocationHandler = new MyInvocationHandler(realSubject);
          //代理对象
          Subject proxyClass = (Subject) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Subject.class}, myInvocationHandler);
      
          proxyClass.sellBooks();
      
          proxyClass.speak();
        }
      }
      ```

2. CGlib

   [Cglib](https://www.runoob.com/w3cnote/cglibcode-generation-library-intro.html) 动态代理是针对代理的类，动态生成一个子类，然后子类覆盖代理类中的方法，如果是private或是final类修饰的方法,则不会被重写。

   CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。

   CGLIB作为一个开源项目，其代码托管在github，地址为：https://github.com/cglib/cglib

   + 需要代理的类:

     ```java
     public class Engineer {
       // 可以被代理
       public void eat() {
         System.out.println("工程师正在吃饭");
       }
       // final 方法不会被生成的字类覆盖
       public final void work() {
         System.out.println("工程师正在工作");
       }
       // private 方法不会被生成的字类覆盖
       private void play() {
         System.out.println("this engineer is playing game");
       }
     }
     ```

   + CGLIB 代理类:

     ```java
     public class CglibProxy implements MethodInterceptor {
       private Object target;
     
       public CglibProxy(Object target) {
         this.target = target;
       }
     
       @Override
       public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
         System.out.println("###   before invocation");
         Object result = method.invoke(target, objects);
         System.out.println("###   end invocation");
         return result;
       }
     
       public static Object getProxy(Object target) {
         Enhancer enhancer = new Enhancer();
         // 设置需要代理的对象
         enhancer.setSuperclass(target.getClass());
         // 设置代理人
         enhancer.setCallback(new CglibProxy(target));
         return enhancer.create();
       }
     }
     ```

   + 测试方法：

     ```java
     public class CglibMainTest {
       public static void main(String[] args) {
         // 生成 Cglib 代理类
         Engineer engineerProxy = (Engineer) CglibProxy.getProxy(new Engineer());
         // 调用相关方法
         engineerProxy.eat();
       }
     }
     ```

   + 运行结果:

     ```shell
     ###   before invocation
     工程师正在吃饭
     ###   end invocation
     ```

   > 更多内容可以参考：[CGLIB(Code Generation Library) 介绍与原理](https://www.runoob.com/w3cnote/cglibcode-generation-library-intro.html)

# 14. 责任链模式

# 15. 命令模式

# 16. 解释器模式

# 17. 迭代器模式

# 18. 中介者模式

# 19. 备忘录模式

# 20. 状态模式

# 21. 空对象模式

# 22. 策略模式

# 23. 模版模式

​	在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。

## 23.1 介绍

**意图：**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

**主要解决：**一些方法通用，却在每一个子类都重新写了这一方法。

**何时使用：**有一些通用的方法。

**如何解决：**将这些通用算法抽象出来。

**关键代码：**在抽象类实现，其他步骤在子类实现。

**应用实例：** 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、<u>spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存</u>。

**优点：** 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。

**缺点：**每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

**使用场景：** 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。

**注意事项：**<u>为防止恶意操作，一般模板方法都加上 final 关键词</u>。

## 23.2 实现

我们将创建一个定义操作的 *Game* 抽象类，其中，模板方法设置为 final，这样它就不会被重写。*Cricket* 和 *Football* 是扩展了 *Game* 的实体类，它们重写了抽象类的方法。

*TemplatePatternDemo*，我们的演示类使用 *Game* 来演示模板模式的用法。

![模板模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg)

**步骤 1**

创建一个抽象类，它的模板方法被设置为 final。

```java
public abstract class Game {
  abstract void initialize();
  abstract void startPlay();
  abstract void endPlay();

  //模板
  public final void play(){
    //初始化游戏
    initialize();
    //开始游戏
    startPlay();
    //结束游戏
    endPlay();
  }
}
```

**步骤 2**

创建扩展了上述类的实体类。

```java
public class Cricket extends Game {
  @Override
  void endPlay() {
    System.out.println("Cricket Game Finished!");
  }
  @Override
  void initialize() {
    System.out.println("Cricket Game Initialized! Start playing.");
  }
  @Override
  void startPlay() {
    System.out.println("Cricket Game Started. Enjoy the game!");
  }
}
```

```java
public class Football extends Game {
  @Override
  void endPlay() {
    System.out.println("Football Game Finished!");
  }
  @Override
  void initialize() {
    System.out.println("Football Game Initialized! Start playing.");
  }
  @Override
  void startPlay() {
    System.out.println("Football Game Started. Enjoy the game!");
  }
}
```

**步骤 3**

使用 *Game* 的模板方法 play() 来演示游戏的定义方式。

```java
public class TemplatePatternDemo {
  public static void main(String[] args) {
    Game game = new Cricket();
    game.play();
    System.out.println();
    game = new Football();
    game.play();      
  }
}
```

**步骤 4**

执行程序，输出结果：

```
Cricket Game Initialized! Start playing.
Cricket Game Started. Enjoy the game!
Cricket Game Finished!

Football Game Initialized! Start playing.
Football Game Started. Enjoy the game!
Football Game Finished!
```

# 24. 


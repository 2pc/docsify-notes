# 数据库系统内幕-学习笔记-01

# 前言

你将深入了解如下内容：

+ 存储引擎：学习存储的种类、分类依据，理解基于B树和不可变日志存储结构的存储引擎。
+ 存储构建块：理解数据库文件如何使用诸如页缓存、缓冲池等辅助数据结构来组织构建高效的存储。
+ 分布式系统：逐步学习节点和进程间如何连接并构建复杂的通信模式。
+ 数据库集群：深入探究现在数据库中常用的一致性模型，并了解分布式存储系统是如何实现一致性的。

# 第一部分 存储引擎

​	数据库是模块化的系统，由多个部分组成：

+ 接受请求的传输层
+ 决定以最高效方式运行查询的查询处理器
+ 执行操作的执行引擎
+ **存储引擎**

​	存储引擎(或数据库引擎)是数据库的一个软件组件，它负责在**内存和磁盘**上<u>存储、检索和管理数据</u>，而设计它的目的是长久保存每个节点的数据[REED78]。

​	数据库可以响应复杂的査询，存储引擎则会更细粒度地看待数据并提供一组简单的数据操作API，允许用户创建、更新、删除和检索数据记录。从某个角度来看，**数据库是构建在存储引擎之上的应用程序**，<u>它提供了表结构( schema)、查询语言、索引、事务和许多其他有用的特性</u>。

​	<u>为了获得灵活性，键和值都可以是没有预设格式的任意字节序列</u>。它们的排序和表示语义是在更高级别的子系统中定义的。例如，你可以在一个表中使用int32(32位整数)作为键，而在另一个表中使用 ascii(ASCⅡ字符串)；从存储引擎的角度来看，这两个键都只是序列化的条目。

​	BerkeleyDB、 LevelDB(及其后代 RocksDB)、LMDB(及其后代 libmdbx、 Sophia和HaloDB)等存储引擎的开发都**与它们现在所嵌入的数据库彼此独立**。

​	使用**可插拔的存储引擎**使数据库开发人员能够使用现有存储引擎来构建数据库系统，并将精力集中在其他子系统上。

​	同时，**数据库系统组件之间清晰的解耦为切换不同引擎提供了机会，这些引擎可能分别适用于特定的用例**。

​	例如：流行的数据库 MySQL有几个存储引擎，包括 InnoDB、MyISAM和RocksDB（在 MyRocks发行版中），而MongoDB则允许在WiredTiger、内存以及(现已弃用的)MMAPv1存储引擎之间进行切换。

---

+ 数据库的比较

  ​	模拟现实世界中的工作负载不仅能帮助你了解数据库的运行方式，还能帮助你学习如何操作与调试数据库，并了解其社区的友好程度和能提供帮助的程度。数据库的选择总是这些因素的组合，而性能通常并不是最重要的方面：**使用保存数据缓慢的数据库通常比使用会快速丢失数据的数据库要好得多**。

  ​	要比较数据库，非常详细地理解用例并定义当前和预期的变量是有帮助的，例如：

  + 表结构和记录大小
  + 客户端数量
  + 查询类型和访问模式
  + 读写查询速率
  + 任何这些变量中的预期变化

  ​	明确这些变量可以帮助回答以下问题：

  + 数据库支持所需的查询吗？
  + 数据库能够处理我们计划存储的数据量吗？
  + 单个节点可以处理的读写操作有多少？
  + 一个系统计划要有多少个节点？
  + 鉴于预期的增长率，我们如何扩展集群？
  + 维护过程是什么？

  ​	在回答了这些问题之后，你可以构建一个测试集群并模拟你的工作负载。大多数数据库已经有了压测工具，可以用来重现特定的用例。如果没有标准的压测工具用来在数据库生态系统中生成现实中的随机工作负载，那么这可能是一个危险的信号。如果有什么东西让你无法使用数据库自带的工具，那么你可以尝试一个现有的通用工具，或者从零开始实现一个。

  ​	有些人以为，可以将数据库当作黑匣子而无须了解其中的内容是件好事。但实践往往表明，这样做迟早会碰到bug、服务中断、性能倒退或其他问题。你最好为这些问题做好准备，如果你了解并且理解数据库的内部结构，就可以减少业务风险且更有可能快速地恢复。

---

+ TPC-C基准

  ​	事务处理性能委员会(Transaction Processing Performance Council，TPC)提供了一组数据库厂商用来比较和宣传其产品性能的基准。TPC-C是一个**联机事务处理(OLTP)**基准，它是只读事务和更新事务的混合，用于模拟常见的应用程序工作负载。

  ​	该基准关注的是**执行的并发事务的性能和正确性**。主要性能指标是**吞吐量**：**数据库系统每分钟能够处理的事务数**。其需要执行事务具备**ACID属性**并符合基准本身定义的属性集。

  ​	此基准不专注于任何特定的业务部门，但提供了对大多数适用OLTP数据库的应用都很重要的抽象操作集。它包括几个表(tables)和实体(entities)，如仓库(warehouses)、库存(stock/inventory)、客户(customers)和订单(orders)，并指定了表布局(table layouts)、可以对表执行的事务的细节、表的最小行数和数据持久性约束(data durability constraints)。

# 第1章 简介和概述

​	数据库可以用于不同的目的：一些主要用于临时热数据，一些用作长期冷数据的存储，一些允许复杂的分析查询，一些只允许通过键访问值，一些专门对存储时间序列数据进行了优化，一些则可高效地存储二进制大对象(Binary Large Object，BLOB)。为了理解其差异和边界，我们将从简短的分类和概述出发，这有助于我们理解要讨论的范围。

​	一些人将数据库分为三大类。

+ 联机事务处理(OLTP)数据库

  它处理大量面向用户的请求和事务。查询通常是预定义的，并且运行时间都很短。

+ 联机分析处理(OLAP)数据库

  它处理复杂的聚合。OLAP数据库通常用于分析和数据仓库，能够处理复杂的、长时间运行的ad-hoc查询。

+ 混合事务和分析处理(HTAP)数据库

  它结合了OLTP和OLAP存储的属性。	

​	还有许多其他术语和分类：键值存储、关系数据库、面向文档的存储和图数据库。我们假定读者对它们的功能具有髙层次的认知和理解，因此在这里没有对这些概念进行定义。由于我们在这里讨论的概念是广泛适用的，并且对前面提到的大多数数据存储在某种程度上也都是适用的，所以完整的分类方式对于进一步的讨论既不必要也不重要。

## 1.1 数据库架构

![img](https://s6.51cto.com/oss/202103/24/f63b1924e54f62b5a1dadf1cff2dd639.jpg)

​	一些描述数据库架构的信息来源(例如，[HELLERSTEINO7]、[WEIKUM01]、[ELMASRI11]和[MOLINA08]以不同的方式定义了组件及其间的关系。图1-1所示的架构展示了这些表示中的一些常见主题。

​	数据库使用客户端/服务器模型，其中数据库系统实例(节点)扮演服务器的角色，而应用程序实例则扮演客户端的角色。

​	客户端请求通过传输子系统到达数据库。而请求则以査询的形式出现，通常以某种查询语言表示。传输子系统还负责与数据库集群中的其他节点进行通信。

​	在接收到査询后，传输子系统将査询移交给查询处理器，由査询处理器对该査询进行语法解析、解释和验证。稍后，数据库将执行访问控制检査，因为只有在解释査询之后才能完全执行这些检查。

​	<u>解析后的査询被传递给查询优化器，后者首先消除査询中不可能执行的部分与冗余的部分，然后根据内部统计信息(索引基数、近似交集大小等)和数据分布(数据存储在集群中的哪些节点以及传输所需的成本)，尝试找到执行査询的最高效方法。优化器既处理査询解析所需的关系操作(通常表示为依赖关系树)，也处理査询优化(如索引排序、基数估计和访问方法的选择)</u>。

​	**査询通常以执行计划(或查询计划)的形式呈现**。<u>执行计划是为得到完整结果而必须执行的一系列操作。由于执行同一个查询的不同执行计划存在效率上的差异，所以优化器会挑选出最优的计划</u>。

​	执行计划由执行引擎处理，后者收集本地和远程操作的执行结果。远程执行可能涉及向集群中的其他节点写入数据、从其他节点读取数据以及数据复制。

​	本地査询(直接来自客户端或其他节点的査询)由存储引擎执行。存储引擎拥有如下几个具有专门职责的组件。

+ **事务管理器**

  事务管理器调度事务，并确保它们不会使数据库处于逻辑不一致的状态。

+ **锁管理器**

  锁管理器为正在运行的事务锁定数据库对象，确保并发操作不会破坏物理数据的完整性。

+ **访问方法(存储结构)**

  **访问方法(存储结构)管理磁盘上的数据访问并负责组织磁盘上的数据**。访问方法包括堆文件和存储结构，例如B树(参见2.3节)和LSM树(参见7.1节)。

+ **缓冲区管理器**

  缓冲区管理器将数据页缓存在内存中(参见5.1节)。

+ **恢复管理器**

  恢复管理器维护操作日志并在出现故障时还原系统状态(参见5.2节)。

​	<u>**事务管理器和锁管理器共同负责并发控制(参见5.3节)**：它们在保证数据的逻辑和物理完整性的同时，确保尽可能高效地执行并发操作</u>。

## * 1.2 内存数据库与磁盘数据库

+ 小结
  + 内存数据库
    + 特征：内存存储主要数据，磁盘进行日志记录和数据备份。
    + 优势：
      1. 磁盘提供内存管理，资源管理相对磁盘更为简单
      2. 硬件层面内存访问比磁盘快
      3. NVM存储减少甚至完全消除某些场景的读写延迟不对称，提高读写性能，允许字节可寻址访问
      4. **无需像磁盘文件系统一样设计复杂的宽树、矮树数据结构**，可以直接将简单数据结构存储到内存中
    + 劣势：
      1. 相对磁盘昂贵
      2. 天然具有**易失性**，需要接近硬件层面的支持才能尽量弥补该缺陷
      3. 
  + 磁盘数据库
    + 特征：内存作为临时缓存，磁盘存储主要数据。
    + 优势：
      1. 价格便宜，通常用于支持大量数据存储
      2. 数据存储具有持久性，断电数据不丢失
    + 劣势：
      1. 随机读写性能远差于内存，即便是顺序读写也是有性能差距
      2. 需要配合文件系统进行开发，需设计复杂数据结构存储数据

---

​	数据库系统将数据存储在**内存**和**磁盘**上。

+ 内存数据库(有时称为主存数据库( main memoryDBMS)主要将数据储存在内存中，并<u>使用磁盘进行**数据恢复**和**日志记录**</u>。
+ 磁盘数据库则将大部分数据保存在磁盘上，并<u>使用内存来**缓存**磁盘内容或作为**临时存储**</u>。

​	这两种类型的系统在一定程度上都使用磁盘，但主存数据库几乎只将其内容存储在内存中。

​	数据库使用内存作为主要数据存储的主要原因是性能、相对较低的访问成本以及访问粒度。基于內存的编程也比基于磁盘的编程简单得多。<u>操作系统抽象了内存管理，允许我们从分配和释放任意大小的内存块的角度进行思考。而在磁盘上，我们必须手动管理数据引用、序列化格式、释放的空间和碎片</u>。

​	内存数据库增长的主要限制因素是内存的**易失性**(换言之，缺乏数据持久性)以及成本。由于内存中的内容不是持久化的，所以软件缺陷、崩溃、硬件故障和断电都可能导致数据丢失。<u>有一些方法可以确保系统持久运行，例如不间断电源和由电池支持的内存，但它们需要额外的硬件资源和专门的运维知识</u>。在实践中，这些都可以归结为以下事实：**磁盘更容易维护，价格也低得多**。

​	随着**非易失性存储器(NVM)**[ARULRAJ17]技术的可用性和普及程度的提高，内存数据库发展受限的情况可能发生改变。NVM存储减少甚至完全消除了(取决于某个确切的技术)读和写的延迟之间的不对称，进一步提高了读写性能，并**允许字节可寻址(byte addressable)访问**。

---

+ 基于内存存储的持久性

  ​	**数据库在认定操作完成之前，必须先将其结果写入一个顺序日志文件**。我们将在5.2节中更详细地讨论预写日志。
  
  ​	为了避免在启动过程中或崩溃后重放完整的日志内容，内存数据库维护了一个**备份副本**，该备份副本使用一个基于磁盘且已排序的数据结构，并且对该结构的修改通常是**异步(与客户端请求解耦)**且分批处理的，这样可以减少IO操作的数量。
  
  ​	<u>在恢复过程中，数据库可以从备份和日志中还原数据库内容</u>。
  
  ​	**日志数据通常用于批量备份**。在处理该批日志数据之后，备份将持有截止到这一特定时间点的数据库快照，因此可以丢弃之前的日志内容。这个过程称为**生成检查点(checkpointing)**。它会更新磁盘上的数据库快照使其更接近最新的日志条目，从而缩短恢复时间，且<u>备份过程不会阻塞客户端请求</u>。
  
  > 一些说法认为内存数据库相当于一个具有巨大页缓存的磁盘数据库，这是不公平的(见5.1节)。即使页缓存在内存里，序列化格式和数据布局也会使磁盘数据库产生额外的开销，而不会达到与内存数据库相同的优化程度。
  
  ​	磁盘数据库使用专门的存储结构，针对磁盘访问进行了优化。在内存中，我们可以比较快地跟踪指针，并且**随机内存访问比随机磁盘访问要快得多**。
  
  ​	**<u>基于磁盘的存储结构通常具有宽树和矮树的形式</u>**(参见2.1.2节)，而基于内存的实现可以从更大范围的数据结构中进行选择，并实现不可能或难以在磁盘上实现的优化[ MOLINA92]。
  
  ​	同样，处理磁盘上的可变大小数据需要特别注意，而在内存中，这通常是一个用指针来引用值的问题。

## 1.3 面向列和面向行的数据库

​	大多数数据库系统存储一组数据记录，这些记录由表中的列和行组成。**字段是列和行的交集**：某种类型的单个值。属于同一列的字段通常具有相同的数据类型。

​	对数据库进行分类的方法之一是按数据在磁盘上的存储方式进行分类：按行或按列进行分类。表可以水平分区(将属于同一行的值存储在一起)，也可以垂直分区(将属于同列的值存储在一起)。

​	下图描述了这种区别：a)显示了按列分区的值，b)显示了按行分区的值。

![img](http://p6.itc.cn/images01/20200616/e6c67ccfe3c24536a849b0808a34f5fb.jpeg)

> 面向行的数据库的例子很多：MySQL、 PostgreSQL和大多数传统的关系数据库。而两个开源的、面向列数据存储的先驱则是MonetDB和C-Store（C- Store是Vertica的开源前身）。

### 1.3.1 面向行的数据布局

+ 小结
  + 需要按行读取数据的情况下，面向行的数据布局可以提高空间局部性。	
  + 但是只需要一行中某几列时，面向行的读取比面向列的读取开销更大（其他大字段无用列被连带读取）

---

​	面向行的数据库按记录或行来存储数据。它的布局非常接近表格的数据表示方法，即其中每一行都具有相同的字段集合。

​	在需要按行访问数据的情况下，面向行的存储最有用，将整行存储在一起可以提高空间局部性[DENNING68]。

> **空间局部性原则**是局部性原则之一。该原则指岀，如果访冋一处存储，则其附近的其他存储区域也会在不久的将来被访问。

​	因为**诸如磁盘之类的持久性介质上的数据通常是按块访问的**(换句话说，磁盘访问的最小单位是块)，所以单个块可能将包含某行中所有列的数据。这对于我们希望访问整个用户记录的情况非常有用，但这样的存储布局会使访问多个用户记录某个字段的查询(例如，只获取电话号码的查询)开销更大，因为其他字段的数据在这个过程中也会被读入。

### 1.3.2 面向列的数据布局

+ 小结
  + 数据按照列连续存储在磁盘，可按列读写
  + 适合计算聚合的分析型工作负载
  + 为满足连接、筛选和多行聚合等场景，常用一些隐式标识符(虚拟ID)映射到字段（ps：字段即行和列的交集）

---

​	面向列的数据库垂直地将数据进行分区(即通过列进行分区)，而不是将其按行存储。

​	在这种数据存储布局中，**同一列的值被连续地存储在磁盘上**(而不是像前面的示例那样将行连续地存储)。

​	*例如，如果我们要存储股票市场的历史价格，那么股票价格这一列的数据便会被存储在一起。将不同列的值存储在不同的文件或文件段中，可以按列进行有效的查询，因为它们可以一次性地被读取出来，而不是先对整行进行读取后再丢弃掉不需要的列。*

​	**面向列的存储非常适合计算聚合的分析型工作负载**，例如査找趋势、计算平均值等。如果逻辑记录具有多个字段，但是其中某些字段(在本例中为股票价格)具有不同的重要性并且该字段所存储的数据经常被一起使用，那么我们一般使用复杂聚合来处理这样的情况。

​	为了重建数据元组(这对于连接、筛选和多行聚合可能很有用)，我们需要在列级别上保留一些元数据，以标识与它关联的其他列中的数据点是哪些。如果你显式地执行此操作，则需要毎个值都必须持有一个键，这将导致数据重复并增加存储的数据量。针对这种需求，<u>一些列存储使用**隐式标识符(虛拟ID)**，并使用该值的位置(换句话说，其偏移量)将其映射回相关值</u>[ABADI13]。

> 在过去几年中，可能由于对不断增长的数据集运行复杂分析査询的需求不断增长，我们看到了许多新的面向列的文件格式，如 Apache Parquet、 Apache ORC、 RCFile，以及面向列的存储，如 Apache Kudu、 ClickHouse，以及许多其他列式数据存储组件[ROY12]。

### 1.3.3 区别与优化

1. 在一次读取中，从同一列中读取多个值可以显著提高缓存利用率和计算效率。在现代CPU上，向量化指令可以使单条CPU指令一次处理多个数据点[DREPPER07]
2. 另外，将具有相同数据类型的值存储在一起(例如，数字与数字在一起，字符串与字符串在一起)可以提高压缩率。我们可以根据不同的数据类型使用不同的压缩算法，并为每种情况选择最有效的压缩方法。

​	要决定是使用面向列还是面向行的存储，你需要了解访问模式。

+ 如果所读取的记录中的大多数或所有列都是需要的，并且工作负载主要由单条记录查询和范围扫描组成，则面向行的存储布局可能产生更好的结果。
+ 如果扫描跨越多行，或者在列的子集上进行计算聚合，则值得考虑使用面向列的存储布局。

### 1.3.4 宽列式存储

​	**面向列的数据库不应与宽列式存储(如 Big Table或 Hbase)相混淆**。在这些数据库中数据表示为多维映射，列被分组为**列族**(通常存储相同类型的数据)，并且<u>在每个列族中，数据被逐行存储</u>。<u>此布局最适合存储由一个键或一组键来检索的数据</u>。

​	理解宽列式存储的概念表示是有用的，而它们的物理布局也有所不同。列族的数据布局示意图如图1-4所示：列族被单独存储，但在每个列族中，属于同一键的数据被存储在一起。

[![img](https://s3.51cto.com/oss/202103/24/cddb8555ef06ed9e12ad330bc9f6dd86.jpg)](https://s3.51cto.com/oss/202103/24/cddb8555ef06ed9e12ad330bc9f6dd86.jpg)

## 1.4 数据文件和索引文件

​	数据库系统通常将数据文件和索引文件分开：数据文件存储数据记录，而索引文件存储元数据并使用它来定位数据文件中的记录。索引文件的大小通常比数据文件小。文件被划分成页(page)，每个页通常具有单个或多个磁盘块的大小。页可以被组织成记录的序列或分槽页(slotted page)(参见3.5节)。

​	新增记录（插入）和对现有记录的更新使用键/值对来表示。**大多数现代存储系统不显式地删除页上的数据。相反，它们使用删除标记（deletion marker，也称为墓碑（tombstone）），其中包含此删除动作的元数据，如键和时间戳**。在垃圾收集过程中，这些被更新或被删除标记遮盖（shadowed）过的记录所占用的空间会被数据库回收。该过程会读取页，然后将活动（即未被遮盖）的记录写入新位置，并丟弃被遮盖的记录。

### 1.4.1 数据文件

​	数据文件(有时称为主文件(primary file))，通常可以用**索引组织表**(Index-OrganizedTable，IOT)、**堆组织表**heap-organized table，即堆文件)或**哈希组织表**(hash-organized table，即哈希文件)来实现。

+ 在堆文件中的记录不需要遵循任何特定的顺序，并且大多数情况下它们都是按写顺序放置的。这样，在追加新的页时，数据库便不需要额外的工作或文件重组。<u>堆文件需要额外的索引结构来指向存储数据记录的位置，以使其能够被检索到</u>。
+ 在哈希文件中，记录存储在桶中，并且键的哈希值确定记录属于哪个桶。存储在桶中的记录可以按追加顺序存储，也可以按键排序存储以提高査找速度。
+ <u>索引组织表将数据记录存储在索引自身</u>。由于记录是按键的顺序存储的，所以索引组织表中的范围扫描可以通过顺序扫描其内容来实现。

​	**将数据记录存储在索引中使我们能够将磁盘查找的次数至少减少一次，因为在遍历索引并找到搜索到的键之后，我们不必寻址另外的文件来查找相关联的数据记录**。

​	当记录存储在单独的文件中时，索引文件保存着**数据条目**(data entry)，该条目唯一地标识了数据记录，并包含足够的信息使得数据库可以在数据文件中找到它们。例如，我们可以存储文件偏移量(有时称为行定位符)、数据文件中数据记录的位置或哈希文件中的桶ID。**在索引组织表中，数据条目包含实际的数据记录**。

### 1.4.2 索引文件

​	索引是一种为了高效检索数据而对磁盘上的数据记录进行组织的结构。索引文件被组织成专门的结构，将键映射到数据文件里的记录。这些记录由对应的键(在堆文件的情况下)或主键(在索引组织表的情况下)所标识。

​	主(数据)文件上的索引称为主索引。但是，在大多数情况下，我们还可以假设主索引是在主键或作为主键的一组键之上构建的。所有其他索引都称为二级索引(secondary index)。

​	**二级索引可以直接指向数据记录，也可以简单地存储它的主键**。指向数据记录的指针可以保存堆文件或索引组织表中的偏移量。多个二级索引可以指向同一记录，从而允许单个数据记录能够由不同的字段来标识并且可以被不同的索引来定位。虽然主索引文件中毎个搜索键都有一个唯一的条目，但对于每个搜索键，二级索引可能会针对每个搜索键保存多个条目[MOLINA08]。

+ **如果数据记录的顺序遵循搜索键顺序，则这种索引称为聚簇索引(clustered/clustering index)**。聚簇索引中的数据记录通常与索引存储于同一文件，有时也存放在单独的聚簇文件中，而这些文件均保留了键的顺序。
+ **如果数据存储在单独的文件中，且其顺序不遵循键顺序，则索引称为非聚簇索引( nonclustered/ unclustered index)。**

a）一个索引组织表，其数据记录直接储存在索引文件内部。

b）索引文件仅保存偏移量，而用另外的文件保存数据记录。

[![img](https://s4.51cto.com/oss/202103/25/59f11a06b397af52ad8929a332fc7df6.jpg)](https://s4.51cto.com/oss/202103/25/59f11a06b397af52ad8929a332fc7df6.jpg)

> 索引组织表以索引的顺序保存数据，因此按定义一定是聚簇的。主索引通常是聚簇的，而根据定义，二级索引一定不是聚簇的，因为它们是用于加速主键以外的键的访问的。聚簇索引既可以是索引组织的，也可以具有单独的索引和数据文件。

​	**许多数据库系统都有一个固有的、显式的主键，即唯一标识数据库记录的一组列。在未指定主键的情况下，存储引擎可以创建一个隐式主键（例如，MySQL InnoDB引擎会自动添加新的自增列并填充该列的值）**。

​	该术语可以用于不同类型的数据库系统中：关系型数据库系统（如MySQL和PostgreSQL）、基于Dynamo的NoSQL存储（如Apache Cassandra和Riak），以及文档型存储（如MongoDB）。有时候它可能以专属于某个项目的特定名词的形式出现，但大多数情况下我们都可以将那些特定名词与这些术语进行清晰的映射。

### 1.4.3 间接的主索引

​	在数据库社区中，对于是直接通过文件偏移量引用数据记录还是通过主键索引引用数据记录存在不同的意见。两者各有利弊。

1. 两个索引从二级索引文件直接指向数据条目。
2. 二级索引通过主索引间接地定位数据条目。

![img](https://s6.51cto.com/oss/202103/25/9ff39e72fa20f2888aec4e2af17195b7.jpg)

​	我们还可以使用混合方法将数据文件偏移量和主键存储在一起。首先，你要检査数据偏移量是否仍然有效，如果它已经发生变化了，则需要额外对主键索引进行遍历，在找到新的偏移量后更新索引文件。

## * 1.5 缓冲、不可变性和有序性

​	存储引擎基于某些数据结构。但是，<u>这些结构并不描述缓存、恢复、事务性以及存储引擎在它们之上添加的其他内容的语义</u>。

​	在接下来的章节中，我们将从B树开始讨论(参见2.3节)，并试图解释为什么有这么多的B树变体，以及为什么新的数据库存储结构持续不断地出现。

​	存储结构有三个常见变量：是否使用**缓冲**、**使用不可变的还是可变的文件**，以及**是否按顺序存储**值(有序性)。本书中讨论的存储结构之间的大多数区别和优化都与这三个概念中的一个相关。

+ **缓冲**

  ​	缓冲定义了存储结构在将数据放入磁盘之前是否选择在内存中保留一定数量的数据。当然，**<u>毎个基于磁盘的数据结构都必须在某种程度上使用缓冲，因为读写磁盘的最小数据传输单元是块，并且我们希望写入完整的块</u>**。

  ​	在这里，我们讨论的是可避免的缓冲，这是存储引擎的实现者有意为之的事情。我们在本书中首先讨论的优化之一便是向B树节点添加内存缓冲区，以分摊IO成本(参见6.3节)。然而，这并不是我们应用缓冲的唯一方法。例如，尽管双组件LSM树(two-component LSM Tree，参见7.1.1节)与B树相似，但前者以完全不同的方式使用缓冲，并将缓冲与不可变性结合起来。

+ **可变性（或不可变性）**

  + 可变性定义了存储结构是否可以在文件的同一位置中读取文件的某些部分、更新它们并将更新的结果写入文件。
  + **<u>不可变结构是只可追加的：写入后不修改文件内容，而是将修改附加到文件的末尾</u>**。

  ​	除此之外，还有其他方法来实现不可变性，其中之一便是写时复制(copy-on-write，参见6.1节)，其中持有更新记录的(即被修改的)页会被写入文件中的新位置而非原位置。

  ​	<u>通常，LSM树和B树之间的区别便是数据是不可变的还是原地更新的</u>，但是也存在受B树启发但不可变的数据结构(例如，Bw树，见6.5节)。

+ **有序性**

  ​	**有序性定义为数据记录是否按键顺序存储在磁盘上的页中**。换句话说，紧密排序的键存储在磁盘上的连续段中。

  + <u>有序性常常决定了我们能否有效地扫描记录的范围，而不仅仅是定位单个数据记录</u>。
  + **无序存储数据的方式(通常按插入顺序)对于某些写入时的优化提供了可能性**。例如， Bitcask(参见7.4.1节)和 Wisckey(参见7.4.2节)直接在只可追加的文件中存储数据记录。

## 1.6 本章小结

​	在本章中，我们讨论了数据库系统的架构，并介绍了它的主要组件。

​	为了突出基于磁盘的结构的重要性及其与基于内存的结构的区别，我们讨论了基于内存和基于磁盘的存储。我们得出的结论是，基于磁盘的结构对于两种类型的存储都很重要，但其被用于不同的目的。

​	为了解释访问模式如何影响数据库系统的设计，我们讨论了面向行和面向列的数据库以及区分两者的主要因素。为了讨论如何存储数据，我们介绍了数据文件和索引文件。

​	最后，我们介绍了三个核心概念：**缓冲、不可变性和有序性**。我们将在整本书中强调这几个存储引擎的属性。

# 第2章 B树基础知识

​	在上一章中，我们将存储结构分为两类：可变存储结构和不可变存储结构，并确定不可变性为影响数据库设计和实现的核心概念之一。**大多数可变存储结构使用原地更新的机制**。在插入、删除或更新操作期间，数据记录直接在目标文件中原本的位置被更新。

​	存储引擎通常允许同一数据记录在数据库中存在多个版本，例如：当使用多版本并发控制（multi-version concurrency control，参见5.3.6）或分槽页结构（参见3.5节）时。为了简单起见，现在我们假设每个键只与一条数据记录相关联，且该数据记录具有唯的位置。

​	**最流行的存储结构之一是B树**。许多开源数据库系统都基于B树，多年来，这些数据库已经被证明可以覆盖大多数的用例。

​	B树并不是最近才发明的：它是由Rudolph Bayer和 Edward M.McCreight于1971年便引入的概念，此后其越来越流行。到了1979年，B树已经有了相当多的变体， Douglas Comer收集并系统化地整理了其中一些变体[COMER79]。

​	在深入研究B树之前，让我们先讨论一下为什么应该考虑替代传统搜索树(例如，二分搜索树、2-3树和AL树[KNUTH98])。为此，我们先回顾一下什么是二分搜索树。

## 2.1 二分查找树

​	二分搜索树(BST)是一种有序的内存数据结构，可以用来高效地进行键值查找。二分搜索树由多个节点组成，每个树节点由一个键、一个与该键关联的值以及两个子节点指针(因此称为二分)组成。

### 2.1.1 树的平衡

​	插入操作并不会遵循任何特定模式，元素插入可能导致树不平衡的情况(即它的个分支比另一个分支长)。

​	平衡树指的是高度为log<sub>2</sub>N的树(其中N是树中数据项的总数)，并且两个子树之间的高度差不大于1 [KNUTH98]。如果不进行平衡，我们将失去二分搜索树结构的性能优势，使得树的最终形状由插入和删除的顺序来确定。

​	为了防止在一个分支保持为空的时候还在另一个分支上增加新的元素使之变得更长(如图2-3b所示)，我们可以在毎次操作之后对树进行平衡。树的平衡是通过以最小化树高并将每一边的节点数保持在界限内的方式重新组织节点来完成的。

​	保持树的平衡的方法之一是在添加或删除节点后执行旋转：如果插入操作使分支不平衡(分支中的两个连续节点只有一个子节点)，则可以围绕中间节点旋转树。

### * 2.1.2 基于磁盘存储的树

​	如前所述，不平衡树的最差情况的时间复杂度为0(N)。平衡树的平均时间复杂度是0(1ogN)。同时，由于**扇出较低**(扇出是指每个节点允许拥有的最大子节点数)，我们必须相当频繁地执行平衡操作、重新定位节点并更新指针。**维护成本的增加使得二分搜索树作为存储在磁盘上的数据结构变得不切实际**[NIEVERGELT74]。	

​	如果我们想在磁盘上维护二分搜索树，则将面临如下几个问题。

+ 一个问题是**局部性**：由于元素是以随机顺序添加的，所以不能保证新创建的节点是在其父节点附近写入的，这意味着<u>节点子指针可能跨越多个磁盘页</u>。通过修改树的布局和使用**分页二分树**，我们可以在一定程度上改善这种情况(参见2.2.3节)。
+ 另一个与游历子指针的开销密切相关的问题是**树高**。由于二分树的扇出为2，所以树的高度是树中元素个数的以2为底的对数。<u>我们必须执行O(log<sub>2</sub>N)次查找以定位要搜索的元素，这就要求执行相同数量的磁盘传输</u>。2-3树和其他低扇出树具有类似的限制：**<u>虽然它们作为内存数据结构是有用的，但是较小的节点大小使得它们在外部存储上并不实用</u>**[COMER79]。

​	**<u>一个在磁盘上存储二分搜索树的简单方法所需的磁盘寻道次数与比较次数一样多，因为这样的结构原生不具备数据局部性</u>**。这使得我们踏上一条寻找某个可以提供数据局部性的数据结构的道路。

​	考虑到这些因素，更适合磁盘实现的树必须具有以下属性：

+ **高扇出，以改善邻近键的数据局部性。**
+ **低高度，以减少遍历期间的寻道次数。**

> 扇出与高度呈负相关：
>
> + 扇出越高，高度便越低。
> + 如果扇出高，则每个节点可以容纳更多子节点，这降低了节点数量，进而降低了高度

## 2.2 基于磁盘的结构

​	我们已经讨论了基于内存和基于磁盘的存储(参见1.2节)。对于特定的数据结构，我们可以得出相同的区别：有些更适用于磁盘，有些则在内存中工作得更好。

​	正如我们已经讨论过的，**<u>并不是毎个满足空间和时间复杂度要求的数据结构都能高效地用于磁盘存储</u>**。

​	**<u>数据库中使用的数据结构必须加以调整，以适应持久性介质存在的限制</u>**。

​	<u>当数据量大到在内存中保存整个数据集是不可能的或不可行时，通常就需要使用磁盘上的数据结构了。在任何时侯，只有一小部分数据可以缓存在内存中，而其余数据必须以某种允许高效访问的方式被存储在磁盘上</u>。

### * 2.2.1 机械硬盘

​	在大多数传统算法被开发出来的时候，旋转型磁盘是最广为使用的持久性存储介质，而这种硬盘对这些算法的设计产生了很大的影响。后来，存储介质的新发展(如闪存驱动器)激发了新的算法以及对现有算法的改进，以利用新硬件的能力。如今，新型数据结构仍在不断涌现，它们被优化以应用于非易失性的字节可寻址存储(例如，[XIA17]和KANNAN18])。

​	**在旋转型磁盘上，寻道增加了随机读取的成本，因为其需要磁盘旋转和机械磁头运动来将读/写磁头定位到期望的位置。然而，一旦完成了这些高成本的部分，读取或写入连续字节(即顺序操作)的成本就相对较低了**。

​	**<u>旋转型驱动器的最小传送单元是扇区</u>**，因此当执行某些操作时，至少可以读取或写入整个扇区。扇区大小通常从512字节到4KB不等。

​	**<u>磁头定位是机械硬盘(HDD)操作中成本最高的部分</u>**。这就是我们经常听到的顺序IO可以带来正面效果的原因之一：顺序IO将会从磁盘读取和写入连续的存储段。

### * 2.2.2 固态硬盘

​	固态硬盘(SSD)没有可移动的部件：既没有需要旋转的磁盘，也没有为读取而必须移动的磁头。典型的SSD由记忆单元构成，这些单元连接成串(每个串通常为32到64个单元)，串被组合成阵列，阵列被组合成页，页被组合成块[LARRIVEE15]。 

​	根据所使用的某种具体技术，一个单元可以保存一位或多位数据。不同设备的页大小不同，但通常在2KB到16KB之间。块通常包含64到512个页。块被组织成平面(plane)，最后，平面被放置在晶圆核心(die)上。SSD可以具有一个或多个晶圆核心。图2-5展示了这个层次结构。

![img](https://s6.51cto.com/oss/202103/25/fbee98d488b477b3d63c22a276efab95.jpg)

​	**可写(可编程)或可读的最小单元是页**。但是，我们只能对空的记忆单元进行更改(即对写入之前已擦除的单元进行更改)。**<u>最小的擦除实体不是页，而是保存多个页的块，这就是为什么它通常被称为擦除块。空块中的页必须按顺序写入。</u>**

​	**闪存控制器**有一个组件叫作闪存转换层(Flash Translation Layer，FTL)(有关FTL的更多信息，参见7.6.1节)，它负责将页ID映射到对应的物理位置，并跟踪空的、被写过的和被丢弃的页。另外，它还负责垃圾收集，在此期间FTL会查找可以被安全擦除的块。有些块可能仍有活页，在这种情况下，它会将活页从这些块迁移到新位置，并将页ID重新映射到那里。在这之后，它擦除现在未使用的块，使它们变为可写状态。

​	**<u>因为在这两种设备类型(HDD和SSD)中，我们都是面向一定量的数据(例如，逐块访问数据)而不是单个字节来操作的，所以大多数操作系统都具有块设备这个抽象</u>**[CESATIO5]。它隐藏内部磁盘结构并在操作系统内部缓冲I/O操作，**<u>因此毎当我们从块设备读取单个字时，包含它的整个块将会被读取</u>**。这是我们不能忽视的一个限制，在处理基于磁盘存储的数据结构时应该始终考虑到这一点。

​	<u>在SSD中，我们并不像在HDD中那样非常强调随机I/O和顺序I/O的区别，因为随机读取和顺序读取之间的延迟差异并不是很大</u>。不过由于预取、读取连续的页和内部并行性的缘故，二者仍然存在一些差异[GOOSSAERT14]。

​	<u>尽管垃圾收集通常是一个后台操作，但它可能会对写性能产生负面影响，特别是在随机和未对齐的写工作负载的情况下</u>。

​	<u>只写完整的块并将后续写操作组合到同一个块中，可以帮助减少所需的IO操作的数量</u>。在后面的章中，针对实现这一目标的方法，我们将讨论**缓冲**和**不变性**。

### * 2.2.3 磁盘存储结构

​	**<u>除了磁盘访问本身的成本之外，磁盘操作的最小单元是块这一事实是构建有效的磁盘存储结枃的主要限制和设计条件</u>**。要跟踪指向块内特定位置的指针，我们必须获取整个块。既然不得不这样做，那么我们可以通过更改数据结构的布局来利用这个条件。

​	在本章中，我们已经多次提到指针，但是这个词对于不同磁盘存储结构的语义稍有不同。在磁盘上，大部分时间我们都手动管理数据布局(除非我们使用内存映射文件)。虽然这类似于常规指针的操作，但我们必须计算目标指针的地址并显式地追踪该指针。

​	在大多数情况下，磁盘上的偏移量是预先计算出来的(即指针在它所指向的那部分内容被存储之前被写入磁盘)，或者缓存在内存中直到其被刷写到磁盘上。<u>在磁盘结构中创建长依赖链会极大地增加代码和结构的复杂性，因此最好将指针的数量及其跨度保持最小</u>。

​	总之，磁盘存储结构的设计要考虑到其目标存储介质的特性，并且通常要为实现更少的磁盘访问进行优化。我们可以通过**提高局部性**、**优化结构的内部表示**以及**减少页外指针的数量**来实现这一点。

​	在2.1节中，我们得岀结论，即高扇出和低高度是实现最佳磁盘数据结构所需的特性。我们还讨论了来自指针的额外空间开销，以及由于平衡而重新映射这些指针所带来的维护开销。
​	**<u>B树结合了这些思想：增加节点扇出、减少树高和节点指针的数量、降低平衡操作的频率</u>**。

---

+ 分页二分树

  ​	通过将节点分组到页来设计二分树的布局(如图2-6所示)改善了数据局部性。要找到下一个节点，只需在已经获取的页面中追踪指针即可。但是，其间的节点和指针仍然会产生一些开销。在磁盘上布局结构并进行进一步维护是一项不容易的工作，特别是在键和值不是预先排好序而是以随机形式添加的时候。**平衡需要页重组，这又会导致指针更新**。

  ![img](https://s6.51cto.com/oss/202103/25/eba2710e14a6a28b6767d8b3f3630563.jpg)



## 2.3 无处不在的B树

​	可以将B树看作图书馆里一个巨大的目录室：你首先必须选择正确的柜子，然后在那个柜子里选择正确的架子，接下来在架子上选择正确的抽屉，最后浏览抽屉里的卡片，找到你正在寻找的那一个。类似地，B树构建了一个帮助快速导航和定位搜索项的层次结构。

​	正如我们在2.1节中所讨论的，B树是建立在平衡搜索树的基础上的，不同之处在于前者具有更高的扇出(即具有更多的子节点)和更低的高度。

​	在大多数文献中，二分树节点被绘制为圆形。由于每个节点只负责一个键，并将存储范围划分为两部分，所以这种层次的细节表现是高效和直观的。而B树节点则通常被绘制为矩形，并且指针块也被显式地表现出来，以突出子节点和分隔符键之间的关系。图2-7并排显示了二分树节点、2-3树节点和B树节点，这有助于你理解它们之间的异同。

![img](https://s5.51cto.com/oss/202103/25/cd77c1f71f951a995fece01c3d8020c5.jpg)

​	没有东西阻止我们以同样的方式描绘二分树。这两种结构具有相似的指针追踪语义，而在如何维持平衡方面表现出差异。图2-8展示并提示了二分搜索树和B树之间的相似性：在这两种情况下，键将树分成子树，并用于遍历这棵树和查找要搜索的键。你可以将其与图2-1进行比较。

![img](https://s2.51cto.com/oss/202103/25/179a0c5c3105fa373109db4999e4642b.jpg)

​	**B树是有序的：B树节点内的键按顺序存储**。因此，我们可以使用像二分搜索这样的算法来定位搜索到的键。这也意味着B树中的查找具有对数复杂度。例如，在40亿（4×10<sup>9</sup>）个项中找到搜索的关键字需要大约32次比较（有关此主题的更多信息，参见2.3.3节）。

​	**<u>如果每一次比较都进行一次磁盘搜索，则搜索速度将大大降低，但是由于B树节点存储数十甚至数百个数据项，所以我们只需要在每个层跳转时进行一次磁盘搜索</u>**。我们将在后面更详细地讨论查找算法。 

​	使用B树，我们可以有效地执行单点查询和范围查询。在大多数查询语言中，我们通过谓词相等（=）表示单点查询来定位单个项，而通过谓词比较（<、>、≤和≥）表示范围查询来按顺序查询多个数据项。

### 2.3.1 B树的层次结构

​	B树由多个节点组成。每个节点最多可容纳N个键和N+1个指向子节点的指针。这些节点在逻辑上分为三类。 

+ 根节点

  根节点没有父节点，是树的顶端。

+ 叶节点

  叶节点是没有子节点的底层节点。

+ 内部节点

  连接根节点和叶节点的其他节点，B树通常包含多层的内部节点。

该层次结构如图2-9所示。

![img](https://s6.51cto.com/oss/202103/25/ba4b95867baf3aa9b9c340480cabc356.jpg)

​	<u>由于B树是一种页组织技术（即用于组织和导航固定大小的页的技术），所以节点和页这两个术语在描述中可相互替换</u>。

​	<u>节点容量与其实际持有的键的个数之间的关系称为占用率</u>。

​	**B树的特征在于其扇出（fanout）**：存储在每个节点中的键的个数。

+ <u>**为保持树的平衡需要做出一些结构上的更改，而更高的扇出则有助于均摊这些更改的所带来的开销。**</u>
+ <u>**同时，通过在单个块或多个连续块中存储指向子节点的键和指针，可以减少寻道的次数。平衡操作（即分裂和合并）会在节点已满或几乎为空时被触发**。</u>

---

+ B+树 

  ​	我们使用术语“B树”作为一类共享所有或大部分上述属性的数据结构的统称。其实我们所描述的数据结构的更精确的名称是B+树。[KNUTH98]将具有高扇出的树称为多向树（multiway tree）。 

  ​	**<u>B树允许在根节点、内部节点和叶节点当中的任意层上储存值。而B+树则仅在叶节点中存储值，其内部节点仅存储分隔键，用于指引搜索算法去找到叶节点上的关联值</u>**。 

  ​	<u>由于B+树中的值仅存储在叶节点这一层上，所以所有操作（插入、更新、删除和检索数据记录）仅影响叶节点，并且这些操作仅在分裂和合并期间才会传播到更高层</u>。

  ​	B+树广为人知，因此我们像其他文献中一样称之为B树。例如，在[GRAEFE11]中，B+树被指定为默认设计，MySQL InnoDB也将其B+树的实现称为B树。

### * 2.3.2 分隔键

​	存储在B树节点中的键称为索引条目(index entry)、分隔键(separator key)或分隔符单元格(divider cel)。它将树分割成子树(也称为分支或子范围)，其持有包含对应键的范围。**键存储时已经排好序，以便使用二分搜索**。査找算法通过定位一个键并跟随相应的指针从较高的层次移动到较低的层次来找到一个子树。

​	节点中的第一个指针指向小于第一个键的数据所在的子树，节点中的最后一个指针指向大于或等于最后一个键的数据所在的子树。其他指针指向两个键之间的子树K<sub>i-1</sub>≤K<sub>s</sub><K<sub>i</sub>,其中K是一组键，K<sub>s</sub>是属于子树的键。图2-10展示了这些不变式。

![img](https://s5.51cto.com/oss/202103/25/1fd7418cde3e1a79a1dc943fa0d6a127.jpg)

​	<u>一些B树变体还具有**同级节点指针**，它们通常位于**叶子层**上，以简化范围扫描</u>。这些指针有助于避免在查找下一个同级节点时还要返回到父级节点的情况。一些实现在两个方向上都有指针，在叶子层上形成一个**双链表**，<u>这使得逆向迭代成为可能</u>。

​	**使B树与众不同的是，它不是自上而下构建的(像二分搜索树那样)，而是采用相反的构建方式——自下而上。随着叶节点数量的增加，内部节点的数量和树的高度也将增加。**

​	<u>由于B树在节点内部为将来的插入和更新保留了额外的空间，所以树的存储占用率可以低至50%，但通常这个数值要高得多。较高的占用率不会对B树的性能产生负面影响</u>。

### 2.3.3 B树查找复杂度

​	可以从两个角度来讨论B树査找的复杂度：**块传输的数量**和**查找期间完成的比较的次数**。

​	就传输次数而言，对数基为N(毎个节点的键数)。从根节点每往下走一层，节点个数就多K倍，并且跟随一个子指针可以将搜索空间减少至N分之一。在查找期间，最多寻址log<sub>K</sub>M(其中M是B树中的项的总数)个页来査找一个搜索键。在从根到叶的通路上必须经过的子指针的数量也等于层数，换句话说，其等于树的高度h。

​	从比较次数的角度来看，对数基是2，因为在每个节点内搜索一个键是使用二分搜索完成的。每次比较都将搜索空间减半，因此复杂度为log<sub>2</sub>M。

​	了解寻道次数和比较次数之间的区别有助于我们从这两个角度直观地认识搜索是如何执行的，并理解其有着怎样的查找复杂度。

### * 2.3.4 B树查找算法

​	既然我们已经介绍了B树的结构和内部组织，我们就可以定义查找、插入和删除的算法了。<u>要在B树中找到一个项，我们必须执行从根节点到叶节点的单向遍历</u>。这种搜索的目的是査找被搜索的键或其前驱。

+ **査找精确匹配用于单点査询、更新和删除；**
+ **查找其前驱则对于范围扫描和插入非常有用。**

​	该算法从根节点上开始执行二分搜索算法，将要搜索的键与存储在根节点中的键进行比较，直到找到大于要搜索的键的第一个分隔键。这样便定位了一个要搜索的子树。正如前面所讨论的，索引键将树分割成多个子树，子树的边界位于两个相邻的键之间。<u>一旦找到子树，我们就顺着相应的指针继续相同的搜索过程(定位分隔键然后顺着指针往下找)，直到我们到达目标叶节点，在那里我们要么找到了搜索的键，要么通过定位它的前驱节点而得出它不存在的结论</u>。

​	每到一层，我们将得到一个更详细的树的视图：我们从最粗粒度的层(树的根节点)开始，然后下降到下一层，在那里，键可以表示更精确、更详细的范围，直到我们最终到达数据记录所在的叶节点。

+ **在进行单点査询时，在找到或找不到所搜索的键之后搜索便结束了**。
+ **而在进行范围扫描时，迭代从找到的最近的键值对开始，并顺着同级指针继续移动，直到到达范围的末尾或用尽范围谓词为止**。

### 2.3.5 键的数目

​	纵观文献，你可以找到描述键和子节点偏移量数目的不同方法。[BAYER72]提到了一个表示最佳页大小的、依赖于设备的自然数k。在这种情况下，页可以保存k到2k个键，但是可以被部分填充并保存最少k+1、最多2k+1个指向子节点的指针。根页可以容纳1到2k个键。之后，一个参数l被引入，并且任何非叶页都可以具有l+1个键。

​	其他文献，例如[GRAEFE11]，则描述了可以容纳多达N个分隔键和N+1个指针的节点，这些节点具有类似的语义和不变式。

​	这两种方法给我们带来了相同的结果，而其间的差异仅用于强调每篇文献的内容有所不同。在本书中，为了清楚起见，我们坚持使用N作为键的数目(对于叶节点则是键值对的数目)。

### 2.3.6 B树的节点分裂

P40

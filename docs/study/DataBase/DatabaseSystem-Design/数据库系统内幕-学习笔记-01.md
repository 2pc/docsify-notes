# 数据库系统内幕-学习笔记-01

# 前言

你将深入了解如下内容：

+ 存储引擎：学习存储的种类、分类依据，理解基于B树和不可变日志存储结构的存储引擎。
+ 存储构建块：理解数据库文件如何使用诸如页缓存、缓冲池等辅助数据结构来组织构建高效的存储。
+ 分布式系统：逐步学习节点和进程间如何连接并构建复杂的通信模式。
+ 数据库集群：深入探究现在数据库中常用的一致性模型，并了解分布式存储系统是如何实现一致性的。

# 第一部分 存储引擎

​	数据库是模块化的系统，由多个部分组成：

+ 接受请求的传输层
+ 决定以最高效方式运行查询的查询处理器
+ 执行操作的执行引擎
+ **存储引擎**

​	存储引擎(或数据库引擎)是数据库的一个软件组件，它负责在**内存和磁盘**上<u>存储、检索和管理数据</u>，而设计它的目的是长久保存每个节点的数据[REED78]。

​	数据库可以响应复杂的査询，存储引擎则会更细粒度地看待数据并提供一组简单的数据操作API，允许用户创建、更新、删除和检索数据记录。从某个角度来看，**数据库是构建在存储引擎之上的应用程序**，<u>它提供了表结构( schema)、查询语言、索引、事务和许多其他有用的特性</u>。

​	<u>为了获得灵活性，键和值都可以是没有预设格式的任意字节序列</u>。它们的排序和表示语义是在更高级别的子系统中定义的。例如，你可以在一个表中使用int32(32位整数)作为键，而在另一个表中使用 ascii(ASCⅡ字符串)；从存储引擎的角度来看，这两个键都只是序列化的条目。

​	BerkeleyDB、 LevelDB(及其后代 RocksDB)、LMDB(及其后代 libmdbx、 Sophia和HaloDB)等存储引擎的开发都**与它们现在所嵌入的数据库彼此独立**。

​	使用**可插拔的存储引擎**使数据库开发人员能够使用现有存储引擎来构建数据库系统，并将精力集中在其他子系统上。

​	同时，**数据库系统组件之间清晰的解耦为切换不同引擎提供了机会，这些引擎可能分别适用于特定的用例**。

​	例如：流行的数据库 MySQL有几个存储引擎，包括 InnoDB、MyISAM和RocksDB（在 MyRocks发行版中），而MongoDB则允许在WiredTiger、内存以及(现已弃用的)MMAPv1存储引擎之间进行切换。

---

+ 数据库的比较

  ​	模拟现实世界中的工作负载不仅能帮助你了解数据库的运行方式，还能帮助你学习如何操作与调试数据库，并了解其社区的友好程度和能提供帮助的程度。数据库的选择总是这些因素的组合，而性能通常并不是最重要的方面：**使用保存数据缓慢的数据库通常比使用会快速丢失数据的数据库要好得多**。

  ​	要比较数据库，非常详细地理解用例并定义当前和预期的变量是有帮助的，例如：

  + 表结构和记录大小
  + 客户端数量
  + 查询类型和访问模式
  + 读写查询速率
  + 任何这些变量中的预期变化

  ​	明确这些变量可以帮助回答以下问题：

  + 数据库支持所需的查询吗？
  + 数据库能够处理我们计划存储的数据量吗？
  + 单个节点可以处理的读写操作有多少？
  + 一个系统计划要有多少个节点？
  + 鉴于预期的增长率，我们如何扩展集群？
  + 维护过程是什么？

  ​	在回答了这些问题之后，你可以构建一个测试集群并模拟你的工作负载。大多数数据库已经有了压测工具，可以用来重现特定的用例。如果没有标准的压测工具用来在数据库生态系统中生成现实中的随机工作负载，那么这可能是一个危险的信号。如果有什么东西让你无法使用数据库自带的工具，那么你可以尝试一个现有的通用工具，或者从零开始实现一个。

  ​	有些人以为，可以将数据库当作黑匣子而无须了解其中的内容是件好事。但实践往往表明，这样做迟早会碰到bug、服务中断、性能倒退或其他问题。你最好为这些问题做好准备，如果你了解并且理解数据库的内部结构，就可以减少业务风险且更有可能快速地恢复。

---

+ TPC-C基准

  ​	事务处理性能委员会(Transaction Processing Performance Council，TPC)提供了一组数据库厂商用来比较和宣传其产品性能的基准。TPC-C是一个**联机事务处理(OLTP)**基准，它是只读事务和更新事务的混合，用于模拟常见的应用程序工作负载。

  ​	该基准关注的是**执行的并发事务的性能和正确性**。主要性能指标是**吞吐量**：**数据库系统每分钟能够处理的事务数**。其需要执行事务具备**ACID属性**并符合基准本身定义的属性集。

  ​	此基准不专注于任何特定的业务部门，但提供了对大多数适用OLTP数据库的应用都很重要的抽象操作集。它包括几个表(tables)和实体(entities)，如仓库(warehouses)、库存(stock/inventory)、客户(customers)和订单(orders)，并指定了表布局(table layouts)、可以对表执行的事务的细节、表的最小行数和数据持久性约束(data durability constraints)。

# 第1章 简介和概述

​	数据库可以用于不同的目的：一些主要用于临时热数据，一些用作长期冷数据的存储，一些允许复杂的分析查询，一些只允许通过键访问值，一些专门对存储时间序列数据进行了优化，一些则可高效地存储二进制大对象(Binary Large Object，BLOB)。为了理解其差异和边界，我们将从简短的分类和概述出发，这有助于我们理解要讨论的范围。

​	一些人将数据库分为三大类。

+ 联机事务处理(OLTP)数据库

  它处理大量面向用户的请求和事务。查询通常是预定义的，并且运行时间都很短。

+ 联机分析处理(OLAP)数据库

  它处理复杂的聚合。OLAP数据库通常用于分析和数据仓库，能够处理复杂的、长时间运行的ad-hoc查询。

+ 混合事务和分析处理(HTAP)数据库

  它结合了OLTP和OLAP存储的属性。	

​	还有许多其他术语和分类：键值存储、关系数据库、面向文档的存储和图数据库。我们假定读者对它们的功能具有髙层次的认知和理解，因此在这里没有对这些概念进行定义。由于我们在这里讨论的概念是广泛适用的，并且对前面提到的大多数数据存储在某种程度上也都是适用的，所以完整的分类方式对于进一步的讨论既不必要也不重要。

## 1.1 数据库架构

![img](https://s6.51cto.com/oss/202103/24/f63b1924e54f62b5a1dadf1cff2dd639.jpg)

​	一些描述数据库架构的信息来源(例如，[HELLERSTEINO7]、[WEIKUM01]、[ELMASRI11]和[MOLINA08]以不同的方式定义了组件及其间的关系。图1-1所示的架构展示了这些表示中的一些常见主题。

​	数据库使用客户端/服务器模型，其中数据库系统实例(节点)扮演服务器的角色，而应用程序实例则扮演客户端的角色。

​	客户端请求通过传输子系统到达数据库。而请求则以査询的形式出现，通常以某种查询语言表示。传输子系统还负责与数据库集群中的其他节点进行通信。

​	在接收到査询后，传输子系统将査询移交给查询处理器，由査询处理器对该査询进行语法解析、解释和验证。稍后，数据库将执行访问控制检査，因为只有在解释査询之后才能完全执行这些检查。

​	<u>解析后的査询被传递给查询优化器，后者首先消除査询中不可能执行的部分与冗余的部分，然后根据内部统计信息(索引基数、近似交集大小等)和数据分布(数据存储在集群中的哪些节点以及传输所需的成本)，尝试找到执行査询的最高效方法。优化器既处理査询解析所需的关系操作(通常表示为依赖关系树)，也处理査询优化(如索引排序、基数估计和访问方法的选择)</u>。

​	**査询通常以执行计划(或查询计划)的形式呈现**。<u>执行计划是为得到完整结果而必须执行的一系列操作。由于执行同一个查询的不同执行计划存在效率上的差异，所以优化器会挑选出最优的计划</u>。

​	执行计划由执行引擎处理，后者收集本地和远程操作的执行结果。远程执行可能涉及向集群中的其他节点写入数据、从其他节点读取数据以及数据复制。

​	本地査询(直接来自客户端或其他节点的査询)由存储引擎执行。存储引擎拥有如下几个具有专门职责的组件。

+ **事务管理器**

  事务管理器调度事务，并确保它们不会使数据库处于逻辑不一致的状态。

+ **锁管理器**

  锁管理器为正在运行的事务锁定数据库对象，确保并发操作不会破坏物理数据的完整性。

+ **访问方法(存储结构)**

  **访问方法(存储结构)管理磁盘上的数据访问并负责组织磁盘上的数据**。访问方法包括堆文件和存储结构，例如B树(参见2.3节)和LSM树(参见7.1节)。

+ **缓冲区管理器**

  缓冲区管理器将数据页缓存在内存中(参见5.1节)。

+ **恢复管理器**

  恢复管理器维护操作日志并在出现故障时还原系统状态(参见5.2节)。

​	<u>**事务管理器和锁管理器共同负责并发控制(参见5.3节)**：它们在保证数据的逻辑和物理完整性的同时，确保尽可能高效地执行并发操作</u>。

## 1.2 内存数据库与磁盘数据库

+ 小结
  + 内存数据库
    + 特征：内存存储主要数据，磁盘进行日志记录和数据备份。
    + 优势：
      1. 磁盘提供内存管理，资源管理相对磁盘更为简单
      2. 硬件层面内存访问比磁盘快
      3. NVM存储减少甚至完全消除某些场景的读写延迟不对称，提高读写性能，允许字节可寻址访问
      4. **无需像磁盘文件系统一样设计复杂的宽树、矮树数据结构**，可以直接将简单数据结构存储到内存中
    + 劣势：
      1. 相对磁盘昂贵
      2. 天然具有**易失性**，需要接近硬件层面的支持才能尽量弥补该缺陷
      3. 
  + 磁盘数据库
    + 特征：内存作为临时缓存，磁盘存储主要数据。
    + 优势：
      1. 价格便宜，通常用于支持大量数据存储
      2. 数据存储具有持久性，断电数据不丢失
    + 劣势：
      1. 随机读写性能远差于内存，即便是顺序读写也是有性能差距
      2. 需要配合文件系统进行开发，需设计复杂数据结构存储数据

---

​	数据库系统将数据存储在**内存**和**磁盘**上。

+ 内存数据库(有时称为主存数据库( main memoryDBMS)主要将数据储存在内存中，并<u>使用磁盘进行**数据恢复**和**日志记录**</u>。
+ 磁盘数据库则将大部分数据保存在磁盘上，并<u>使用内存来**缓存**磁盘内容或作为**临时存储**</u>。

​	这两种类型的系统在一定程度上都使用磁盘，但主存数据库几乎只将其内容存储在内存中。

​	数据库使用内存作为主要数据存储的主要原因是性能、相对较低的访问成本以及访问粒度。基于內存的编程也比基于磁盘的编程简单得多。<u>操作系统抽象了内存管理，允许我们从分配和释放任意大小的内存块的角度进行思考。而在磁盘上，我们必须手动管理数据引用、序列化格式、释放的空间和碎片</u>。

​	内存数据库增长的主要限制因素是内存的**易失性**(换言之，缺乏数据持久性)以及成本。由于内存中的内容不是持久化的，所以软件缺陷、崩溃、硬件故障和断电都可能导致数据丢失。<u>有一些方法可以确保系统持久运行，例如不间断电源和由电池支持的内存，但它们需要额外的硬件资源和专门的运维知识</u>。在实践中，这些都可以归结为以下事实：**磁盘更容易维护，价格也低得多**。

​	随着**非易失性存储器(NVM)**[ARULRAJ17]技术的可用性和普及程度的提高，内存数据库发展受限的情况可能发生改变。NVM存储减少甚至完全消除了(取决于某个确切的技术)读和写的延迟之间的不对称，进一步提高了读写性能，并**允许字节可寻址(byte addressable)访问**。

---

+ 基于内存存储的持久性

  ​	**数据库在认定操作完成之前，必须先将其结果写入一个顺序日志文件**。我们将在5.2节中更详细地讨论预写日志。
  
  ​	为了避免在启动过程中或崩溃后重放完整的日志内容，内存数据库维护了一个**备份副本**，该备份副本使用一个基于磁盘且已排序的数据结构，并且对该结构的修改通常是**异步(与客户端请求解耦)**且分批处理的，这样可以减少IO操作的数量。
  
  ​	<u>在恢复过程中，数据库可以从备份和日志中还原数据库内容</u>。
  
  ​	**日志数据通常用于批量备份**。在处理该批日志数据之后，备份将持有截止到这一特定时间点的数据库快照，因此可以丢弃之前的日志内容。这个过程称为**生成检查点(checkpointing)**。它会更新磁盘上的数据库快照使其更接近最新的日志条目，从而缩短恢复时间，且<u>备份过程不会阻塞客户端请求</u>。
  
  > 一些说法认为内存数据库相当于一个具有巨大页缓存的磁盘数据库，这是不公平的(见5.1节)。即使页缓存在内存里，序列化格式和数据布局也会使磁盘数据库产生额外的开销，而不会达到与内存数据库相同的优化程度。
  
  ​	磁盘数据库使用专门的存储结构，针对磁盘访问进行了优化。在内存中，我们可以比较快地跟踪指针，并且**随机内存访问比随机磁盘访问要快得多**。
  
  ​	**<u>基于磁盘的存储结构通常具有宽树和矮树的形式</u>**(参见2.1.2节)，而基于内存的实现可以从更大范围的数据结构中进行选择，并实现不可能或难以在磁盘上实现的优化[ MOLINA92]。
  
  ​	同样，处理磁盘上的可变大小数据需要特别注意，而在内存中，这通常是一个用指针来引用值的问题。

## 1.3 面向列和面向行的数据库

​	大多数数据库系统存储一组数据记录，这些记录由表中的列和行组成。**字段是列和行的交集**：某种类型的单个值。属于同一列的字段通常具有相同的数据类型。

​	对数据库进行分类的方法之一是按数据在磁盘上的存储方式进行分类：按行或按列进行分类。表可以水平分区(将属于同一行的值存储在一起)，也可以垂直分区(将属于同列的值存储在一起)。

​	下图描述了这种区别：a)显示了按列分区的值，b)显示了按行分区的值。

![img](http://p6.itc.cn/images01/20200616/e6c67ccfe3c24536a849b0808a34f5fb.jpeg)

> 面向行的数据库的例子很多：MySQL、 PostgreSQL和大多数传统的关系数据库。而两个开源的、面向列数据存储的先驱则是MonetDB和C-Store（C- Store是Vertica的开源前身）。

### 1.3.1 面向行的数据布局

+ 小结
  + 需要按行读取数据的情况下，面向行的数据布局可以提高空间局部性。	
  + 但是只需要一行中某几列时，面向行的读取比面向列的读取开销更大（其他大字段无用列被连带读取）

---

​	面向行的数据库按记录或行来存储数据。它的布局非常接近表格的数据表示方法，即其中每一行都具有相同的字段集合。

​	在需要按行访问数据的情况下，面向行的存储最有用，将整行存储在一起可以提高空间局部性[DENNING68]。

> **空间局部性原则**是局部性原则之一。该原则指岀，如果访冋一处存储，则其附近的其他存储区域也会在不久的将来被访问。

​	因为**诸如磁盘之类的持久性介质上的数据通常是按块访问的**(换句话说，磁盘访问的最小单位是块)，所以单个块可能将包含某行中所有列的数据。这对于我们希望访问整个用户记录的情况非常有用，但这样的存储布局会使访问多个用户记录某个字段的查询(例如，只获取电话号码的查询)开销更大，因为其他字段的数据在这个过程中也会被读入。

### 1.3.2 面向列的数据布局

+ 小结
  + 数据按照列连续存储在磁盘，可按列读写
  + 适合计算聚合的分析型工作负载
  + 为满足连接、筛选和多行聚合等场景，常用一些隐式标识符(虚拟ID)映射到字段（ps：字段即行和列的交集）

---

​	面向列的数据库垂直地将数据进行分区(即通过列进行分区)，而不是将其按行存储。

​	在这种数据存储布局中，**同一列的值被连续地存储在磁盘上**(而不是像前面的示例那样将行连续地存储)。

​	*例如，如果我们要存储股票市场的历史价格，那么股票价格这一列的数据便会被存储在一起。将不同列的值存储在不同的文件或文件段中，可以按列进行有效的查询，因为它们可以一次性地被读取出来，而不是先对整行进行读取后再丢弃掉不需要的列。*

​	**面向列的存储非常适合计算聚合的分析型工作负载**，例如査找趋势、计算平均值等。如果逻辑记录具有多个字段，但是其中某些字段(在本例中为股票价格)具有不同的重要性并且该字段所存储的数据经常被一起使用，那么我们一般使用复杂聚合来处理这样的情况。

​	为了重建数据元组(这对于连接、筛选和多行聚合可能很有用)，我们需要在列级别上保留一些元数据，以标识与它关联的其他列中的数据点是哪些。如果你显式地执行此操作，则需要毎个值都必须持有一个键，这将导致数据重复并增加存储的数据量。针对这种需求，<u>一些列存储使用**隐式标识符(虛拟ID)**，并使用该值的位置(换句话说，其偏移量)将其映射回相关值</u>[ABADI13]。

> 在过去几年中，可能由于对不断增长的数据集运行复杂分析査询的需求不断增长，我们看到了许多新的面向列的文件格式，如 Apache Parquet、 Apache ORC、 RCFile，以及面向列的存储，如 Apache Kudu、 ClickHouse，以及许多其他列式数据存储组件[ROY12]。

### 1.3.3 区别与优化

1. 在一次读取中，从同一列中读取多个值可以显著提高缓存利用率和计算效率。在现代CPU上，向量化指令可以使单条CPU指令一次处理多个数据点[DREPPER07]
2. 另外，将具有相同数据类型的值存储在一起(例如，数字与数字在一起，字符串与字符串在一起)可以提高压缩率。我们可以根据不同的数据类型使用不同的压缩算法，并为每种情况选择最有效的压缩方法。

​	要决定是使用面向列还是面向行的存储，你需要了解访问模式。

+ 如果所读取的记录中的大多数或所有列都是需要的，并且工作负载主要由单条记录查询和范围扫描组成，则面向行的存储布局可能产生更好的结果。
+ 如果扫描跨越多行，或者在列的子集上进行计算聚合，则值得考虑使用面向列的存储布局。

### 1.3.4 宽列式存储

​	**面向列的数据库不应与宽列式存储(如 Big Table或 Hbase)相混淆**。在这些数据库中数据表示为多维映射，列被分组为**列族**(通常存储相同类型的数据)，并且<u>在每个列族中，数据被逐行存储</u>。<u>此布局最适合存储由一个键或一组键来检索的数据</u>。

​	理解宽列式存储的概念表示是有用的，而它们的物理布局也有所不同。列族的数据布局示意图如图1-4所示：列族被单独存储，但在每个列族中，属于同一键的数据被存储在一起。

[![img](https://s3.51cto.com/oss/202103/24/cddb8555ef06ed9e12ad330bc9f6dd86.jpg)](https://s3.51cto.com/oss/202103/24/cddb8555ef06ed9e12ad330bc9f6dd86.jpg)

## 1.4 数据文件和索引文件

​	数据库系统通常将数据文件和索引文件分开：数据文件存储数据记录，而索引文件存储元数据并使用它来定位数据文件中的记录。索引文件的大小通常比数据文件小。文件被划分成页(page)，每个页通常具有单个或多个磁盘块的大小。页可以被组织成记录的序列或分槽页(slotted page)(参见3.5节)。

​	新增记录（插入）和对现有记录的更新使用键/值对来表示。**大多数现代存储系统不显式地删除页上的数据。相反，它们使用删除标记（deletion marker，也称为墓碑（tombstone）），其中包含此删除动作的元数据，如键和时间戳**。在垃圾收集过程中，这些被更新或被删除标记遮盖（shadowed）过的记录所占用的空间会被数据库回收。该过程会读取页，然后将活动（即未被遮盖）的记录写入新位置，并丟弃被遮盖的记录。

### 1.4.1 数据文件

​	数据文件(有时称为主文件(primary file))，通常可以用**索引组织表**(Index-OrganizedTable，IOT)、**堆组织表**heap-organized table，即堆文件)或**哈希组织表**(hash-organized table，即哈希文件)来实现。

+ 在堆文件中的记录不需要遵循任何特定的顺序，并且大多数情况下它们都是按写顺序放置的。这样，在追加新的页时，数据库便不需要额外的工作或文件重组。<u>堆文件需要额外的索引结构来指向存储数据记录的位置，以使其能够被检索到</u>。
+ 在哈希文件中，记录存储在桶中，并且键的哈希值确定记录属于哪个桶。存储在桶中的记录可以按追加顺序存储，也可以按键排序存储以提高査找速度。
+ <u>索引组织表将数据记录存储在索引自身</u>。由于记录是按键的顺序存储的，所以索引组织表中的范围扫描可以通过顺序扫描其内容来实现。

​	**将数据记录存储在索引中使我们能够将磁盘查找的次数至少减少一次，因为在遍历索引并找到搜索到的键之后，我们不必寻址另外的文件来查找相关联的数据记录**。

​	当记录存储在单独的文件中时，索引文件保存着**数据条目**(data entry)，该条目唯一地标识了数据记录，并包含足够的信息使得数据库可以在数据文件中找到它们。例如，我们可以存储文件偏移量(有时称为行定位符)、数据文件中数据记录的位置或哈希文件中的桶ID。**在索引组织表中，数据条目包含实际的数据记录**。

### 1.4.2 索引文件

​	索引是一种为了高效检索数据而对磁盘上的数据记录进行组织的结构。索引文件被组织成专门的结构，将键映射到数据文件里的记录。这些记录由对应的键(在堆文件的情况下)或主键(在索引组织表的情况下)所标识。

​	主(数据)文件上的索引称为主索引。但是，在大多数情况下，我们还可以假设主索引是在主键或作为主键的一组键之上构建的。所有其他索引都称为二级索引(secondary index)。

​	**二级索引可以直接指向数据记录，也可以简单地存储它的主键**。指向数据记录的指针可以保存堆文件或索引组织表中的偏移量。多个二级索引可以指向同一记录，从而允许单个数据记录能够由不同的字段来标识并且可以被不同的索引来定位。虽然主索引文件中毎个搜索键都有一个唯一的条目，但对于每个搜索键，二级索引可能会针对每个搜索键保存多个条目[MOLINA08]。

+ **如果数据记录的顺序遵循搜索键顺序，则这种索引称为聚簇索引(clustered/clustering index)**。聚簇索引中的数据记录通常与索引存储于同一文件，有时也存放在单独的聚簇文件中，而这些文件均保留了键的顺序。
+ **如果数据存储在单独的文件中，且其顺序不遵循键顺序，则索引称为非聚簇索引( nonclustered/ unclustered index)。**

a）一个索引组织表，其数据记录直接储存在索引文件内部。

b）索引文件仅保存偏移量，而用另外的文件保存数据记录。

[![img](https://s4.51cto.com/oss/202103/25/59f11a06b397af52ad8929a332fc7df6.jpg)](https://s4.51cto.com/oss/202103/25/59f11a06b397af52ad8929a332fc7df6.jpg)

> 索引组织表以索引的顺序保存数据，因此按定义一定是聚簇的。主索引通常是聚簇的，而根据定义，二级索引一定不是聚簇的，因为它们是用于加速主键以外的键的访问的。聚簇索引既可以是索引组织的，也可以具有单独的索引和数据文件。

​	**许多数据库系统都有一个固有的、显式的主键，即唯一标识数据库记录的一组列。在未指定主键的情况下，存储引擎可以创建一个隐式主键（例如，MySQL InnoDB引擎会自动添加新的自增列并填充该列的值）**。

​	该术语可以用于不同类型的数据库系统中：关系型数据库系统（如MySQL和PostgreSQL）、基于Dynamo的NoSQL存储（如Apache Cassandra和Riak），以及文档型存储（如MongoDB）。有时候它可能以专属于某个项目的特定名词的形式出现，但大多数情况下我们都可以将那些特定名词与这些术语进行清晰的映射。

### 1.4.3 间接的主索引

P24

# 数据库系统内幕-学习笔记-01

# 前言

你将深入了解如下内容：

+ 存储引擎：学习存储的种类、分类依据，理解基于B树和不可变日志存储结构的存储引擎。
+ 存储构建块：理解数据库文件如何使用诸如页缓存、缓冲池等辅助数据结构来组织构建高效的存储。
+ 分布式系统：逐步学习节点和进程间如何连接并构建复杂的通信模式。
+ 数据库集群：深入探究现在数据库中常用的一致性模型，并了解分布式存储系统是如何实现一致性的。

# 第一部分 存储引擎

​	数据库是模块化的系统，由多个部分组成：

+ 接受请求的传输层
+ 决定以最高效方式运行查询的查询处理器
+ 执行操作的执行引擎
+ **存储引擎**

​	存储引擎(或数据库引擎)是数据库的一个软件组件，它负责在**内存和磁盘**上<u>存储、检索和管理数据</u>，而设计它的目的是长久保存每个节点的数据[REED78]。

​	数据库可以响应复杂的査询，存储引擎则会更细粒度地看待数据并提供一组简单的数据操作API，允许用户创建、更新、删除和检索数据记录。从某个角度来看，**数据库是构建在存储引擎之上的应用程序**，<u>它提供了表结构( schema)、查询语言、索引、事务和许多其他有用的特性</u>。

​	<u>为了获得灵活性，键和值都可以是没有预设格式的任意字节序列</u>。它们的排序和表示语义是在更高级别的子系统中定义的。例如，你可以在一个表中使用int32(32位整数)作为键，而在另一个表中使用 ascii(ASCⅡ字符串)；从存储引擎的角度来看，这两个键都只是序列化的条目。

​	BerkeleyDB、 LevelDB(及其后代 RocksDB)、LMDB(及其后代 libmdbx、 Sophia和HaloDB)等存储引擎的开发都**与它们现在所嵌入的数据库彼此独立**。

​	使用**可插拔的存储引擎**使数据库开发人员能够使用现有存储引擎来构建数据库系统，并将精力集中在其他子系统上。

​	同时，**数据库系统组件之间清晰的解耦为切换不同引擎提供了机会，这些引擎可能分别适用于特定的用例**。

​	例如：流行的数据库 MySQL有几个存储引擎，包括 InnoDB、MyISAM和RocksDB（在 MyRocks发行版中），而MongoDB则允许在WiredTiger、内存以及(现已弃用的)MMAPv1存储引擎之间进行切换。

---

+ 数据库的比较

  ​	模拟现实世界中的工作负载不仅能帮助你了解数据库的运行方式，还能帮助你学习如何操作与调试数据库，并了解其社区的友好程度和能提供帮助的程度。数据库的选择总是这些因素的组合，而性能通常并不是最重要的方面：**使用保存数据缓慢的数据库通常比使用会快速丢失数据的数据库要好得多**。

  ​	要比较数据库，非常详细地理解用例并定义当前和预期的变量是有帮助的，例如：

  + 表结构和记录大小
  + 客户端数量
  + 查询类型和访问模式
  + 读写查询速率
  + 任何这些变量中的预期变化

  ​	明确这些变量可以帮助回答以下问题：

  + 数据库支持所需的查询吗？
  + 数据库能够处理我们计划存储的数据量吗？
  + 单个节点可以处理的读写操作有多少？
  + 一个系统计划要有多少个节点？
  + 鉴于预期的增长率，我们如何扩展集群？
  + 维护过程是什么？

  ​	在回答了这些问题之后，你可以构建一个测试集群并模拟你的工作负载。大多数数据库已经有了压测工具，可以用来重现特定的用例。如果没有标准的压测工具用来在数据库生态系统中生成现实中的随机工作负载，那么这可能是一个危险的信号。如果有什么东西让你无法使用数据库自带的工具，那么你可以尝试一个现有的通用工具，或者从零开始实现一个。

  ​	有些人以为，可以将数据库当作黑匣子而无须了解其中的内容是件好事。但实践往往表明，这样做迟早会碰到bug、服务中断、性能倒退或其他问题。你最好为这些问题做好准备，如果你了解并且理解数据库的内部结构，就可以减少业务风险且更有可能快速地恢复。

---

+ TPC-C基准

  ​	事务处理性能委员会(Transaction Processing Performance Council，TPC)提供了一组数据库厂商用来比较和宣传其产品性能的基准。TPC-C是一个**联机事务处理(OLTP)**基准，它是只读事务和更新事务的混合，用于模拟常见的应用程序工作负载。

  ​	该基准关注的是**执行的并发事务的性能和正确性**。主要性能指标是**吞吐量**：**数据库系统每分钟能够处理的事务数**。其需要执行事务具备**ACID属性**并符合基准本身定义的属性集。

  ​	此基准不专注于任何特定的业务部门，但提供了对大多数适用OLTP数据库的应用都很重要的抽象操作集。它包括几个表(tables)和实体(entities)，如仓库(warehouses)、库存(stock/inventory)、客户(customers)和订单(orders)，并指定了表布局(table layouts)、可以对表执行的事务的细节、表的最小行数和数据持久性约束(data durability constraints)。

# 第1章 简介和概述

​	数据库可以用于不同的目的：一些主要用于临时热数据，一些用作长期冷数据的存储，一些允许复杂的分析查询，一些只允许通过键访问值，一些专门对存储时间序列数据进行了优化，一些则可高效地存储二进制大对象(Binary Large Object，BLOB)。为了理解其差异和边界，我们将从简短的分类和概述出发，这有助于我们理解要讨论的范围。

​	一些人将数据库分为三大类。

+ 联机事务处理(OLTP)数据库

  它处理大量面向用户的请求和事务。查询通常是预定义的，并且运行时间都很短。

+ 联机分析处理(OLAP)数据库

  它处理复杂的聚合。OLAP数据库通常用于分析和数据仓库，能够处理复杂的、长时间运行的ad-hoc查询。

+ 混合事务和分析处理(HTAP)数据库

  它结合了OLTP和OLAP存储的属性。	

​	还有许多其他术语和分类：键值存储、关系数据库、面向文档的存储和图数据库。我们假定读者对它们的功能具有髙层次的认知和理解，因此在这里没有对这些概念进行定义。由于我们在这里讨论的概念是广泛适用的，并且对前面提到的大多数数据存储在某种程度上也都是适用的，所以完整的分类方式对于进一步的讨论既不必要也不重要。

## 1.1 数据库架构

![img](https://s6.51cto.com/oss/202103/24/f63b1924e54f62b5a1dadf1cff2dd639.jpg)

​	一些描述数据库架构的信息来源(例如，[HELLERSTEINO7]、[WEIKUM01]、[ELMASRI11]和[MOLINA08]以不同的方式定义了组件及其间的关系。图1-1所示的架构展示了这些表示中的一些常见主题。

​	数据库使用客户端/服务器模型，其中数据库系统实例(节点)扮演服务器的角色，而应用程序实例则扮演客户端的角色。

​	客户端请求通过传输子系统到达数据库。而请求则以査询的形式出现，通常以某种查询语言表示。传输子系统还负责与数据库集群中的其他节点进行通信。

​	在接收到査询后，传输子系统将査询移交给查询处理器，由査询处理器对该査询进行语法解析、解释和验证。稍后，数据库将执行访问控制检査，因为只有在解释査询之后才能完全执行这些检查。

​	<u>解析后的査询被传递给查询优化器，后者首先消除査询中不可能执行的部分与冗余的部分，然后根据内部统计信息(索引基数、近似交集大小等)和数据分布(数据存储在集群中的哪些节点以及传输所需的成本)，尝试找到执行査询的最高效方法。优化器既处理査询解析所需的关系操作(通常表示为依赖关系树)，也处理査询优化(如索引排序、基数估计和访问方法的选择)</u>。

​	**査询通常以执行计划(或查询计划)的形式呈现**。<u>执行计划是为得到完整结果而必须执行的一系列操作。由于执行同一个查询的不同执行计划存在效率上的差异，所以优化器会挑选出最优的计划</u>。

​	执行计划由执行引擎处理，后者收集本地和远程操作的执行结果。远程执行可能涉及向集群中的其他节点写入数据、从其他节点读取数据以及数据复制。

​	本地査询(直接来自客户端或其他节点的査询)由存储引擎执行。存储引擎拥有如下几个具有专门职责的组件。

+ **事务管理器**

  事务管理器调度事务，并确保它们不会使数据库处于逻辑不一致的状态。

+ **锁管理器**

  锁管理器为正在运行的事务锁定数据库对象，确保并发操作不会破坏物理数据的完整性。

+ **访问方法(存储结构)**

  **访问方法(存储结构)管理磁盘上的数据访问并负责组织磁盘上的数据**。访问方法包括堆文件和存储结构，例如B树(参见2.3节)和LSM树(参见7.1节)。

+ **缓冲区管理器**

  缓冲区管理器将数据页缓存在内存中(参见5.1节)。

+ **恢复管理器**

  恢复管理器维护操作日志并在出现故障时还原系统状态(参见5.2节)。

​	<u>**事务管理器和锁管理器共同负责并发控制(参见5.3节)**：它们在保证数据的逻辑和物理完整性的同时，确保尽可能高效地执行并发操作</u>。

## 1.2 内存数据库与磁盘数据库

​	数据库系统将数据存储在**内存**和**磁盘**上。

+ 内存数据库(有时称为主存数据库( main memoryDBMS)主要将数据储存在内存中，并<u>使用磁盘进行**数据恢复**和**日志记录**</u>。
+ 磁盘数据库则将大部分数据保存在磁盘上，并<u>使用内存来**缓存**磁盘内容或作为**临时存储**</u>。

​	这两种类型的系统在一定程度上都使用磁盘，但主存数据库几乎只将其内容存储在内存中。

​	数据库使用内存作为主要数据存储的主要原因是性能、相对较低的访问成本以及访问粒度。基于內存的编程也比基于磁盘的编程简单得多。<u>操作系统抽象了内存管理，允许我们从分配和释放任意大小的内存块的角度进行思考。而在磁盘上，我们必须手动管理数据引用、序列化格式、释放的空间和碎片</u>。

​	内存数据库增长的主要限制因素是内存的**易失性**(换言之，缺乏数据持久性)以及成本。由于内存中的内容不是持久化的，所以软件缺陷、崩溃、硬件故障和断电都可能导致数据丢失。<u>有一些方法可以确保系统持久运行，例如不间断电源和由电池支持的内存，但它们需要额外的硬件资源和专门的运维知识</u>。在实践中，这些都可以归结为以下事实：**磁盘更容易维护，价格也低得多**。

​	随着**非易失性存储器(NVM)**[ARULRAJ17]技术的可用性和普及程度的提高，内存数据库发展受限的情况可能发生改变。NVM存储减少甚至完全消除了(取决于某个确切的技术)读和写的延迟之间的不对称，进一步提高了读写性能，并**允许字节可寻址(byte addressable)访问**。

---

+ 基于内存存储的持久性

  ​	

# 《Effective-Java第三版》-读书笔记-03

> + `1、`、`2、`表示：第1章、第2章
>
> + `E1`、`E2`表示：第1条、第2条
> + `* X、`表示：个人认为第X章是重点（注意点）
> + `* EX`表示：个人认为第X条是重点（注意点）
>
> 全书共12章，90条目
>
> 下面提到的“设计模式”，指《Design Patterns - Elements of Reusable Object-Oriented Software》一书中提到的23种设计模式

# 9、通用编程
​	本章主要讨论Java语言的细枝末节，包含局部变量的处理、控制结构、类库的用法、各种数据类型的用法，以及两种不是由语言本身提供的机制(**反射机制和本地方法**)的用法。最后讨论了优化和命名惯例。
## E57 将局部变量的作用域最小化
- 概述

  ​	本条目与（E15）本质上是类似的。将局部变量的作用域最小化，可以增强代码的可读性和可维护性，并降低出错的可能性。

  ​	<u>较早的编程语言(如C语言)要求局部变量必须在代码块的开头进行声明</u>，出于习惯，有些程序员目前还是继续这样做。这个习惯应该改正。在此提醒，Java允许你在任何可以出现语句的地方声明变量。

  ​	**要使局部变量的作用域最小化，最有力的方法就是在第一次要使用它的地方进行声明**。如果变量在使用之前进行声明，这只会造成混乱—对于试图理解程序功能的读者来说，这又多了一种只会分散他们注意力的因素。等要用到该变量时，读者可能已经记不起该变量的类型或者初始值了。

  ​	过早地声明局部变量不仅会使它的作用域过早地扩展，而且结束得过晚。局部变量的作用域从它被声明的点开始扩展，一直到外围块的结束处。如果变量是在“使用它的块”之外被声明的，当程序退出该块之后，该变量仍是可见的。如果变量在它的目标使用区域之前或者之后被意外地使用，后果将可能是灾难性的。

  ​	**几乎每一个局部变量的声明都应该包含一个初始化表达式**。如果你还没有足够的信息来对一个变量进行有意义的初始化，就应该推迟这个声明，直到可以初始化为止。<u>这条规则有个例外的情况与try-catch语句有关</u>。

  + **如果一个变量被一个方法初始化，而这个方法可能会抛出一个受检异常，该变量就必须在try块的内部被初始化**。
  + **如果变量的值必须在try块的外部用到，它就必须在try块之前被声明，但是在try块之前，它还不能被“有意义地初始化”**。请参照（E65）中的例子。

  ​	循环中提供了特殊的机会来将变量的作用域最小化。无论是传统的for循环，还是for-each形式的for循环，都允许声明循环变量(loop variable)，它们的作用域被限定在正好需要的范围之内。(这个范围包括循环体，以及循环体之前的初始化、测试、更新部分。因此，如果在循环终止之后不再需要循环变量的内容，for循环就优先于whie循环。

  ​	例如，下面是一种遍历集合的首选做法（E58）

  ```java
  // Preferred idiom for iterating over a collection or array
  for (Element e : c) {
    ... // Do Something with e
  }
  ```

  ​	如果需要访问迭代器，可能要调用它的remove方法，首先做法是利用传统的for循环代替for-each循环：

  ```java
  // Idiom for iterating when you need the iterator
  for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
    ... // Do something with e and i
  }
  ```

  ​	为了弄清楚为什么这些for循环比while循环更好，请参考下面的代码片段，它包含两个while循环，以及一个Bug：

  ```java
  Iterator<Element> i = c.iterator();
  while(i.hasNext()) {
    doSomething(i.next());
  }
  ...
  Iterator<Element> i2 = c2.iterator();
  while(i.hasNext()) { // BUG!
    doSomethingElse(i2.next());
  }
  ```

  ​	第二个循环中包含一个“剪切一粘贴”错误:本来是要初始化一个新的循环变量i2，却使用了旧的循环变量i，遗憾的是，这时i仍然还在有效范围之内。结果代码仍然可以通过编译，运行的时候也不会抛出异常，但是它所做的事情却是错误的。第二个循环并没有在c2上迭代，而是立即终止，造成c2为空的假象。因为这个程序的错误是悄然发生的，所以可能在很长时间内都不会被发现。

  ​	如果类似的“剪切-粘贴”错误发生在前面任何一种for循环中，结果代码根本就不能通过编译。在第二个循环开始之前，第一个循环的元素(或者迭代器)变量已经不在它的作用域范围之内了。下面就是一个传统for循环的例子：

  ```java
  for (Iterator<Element> i = c.iterator(); i.hasNext(); ){
    Element e = i.next();
    ... // Do something with e and i
  }
  ...
  // Compile-time error - cannot find symbol i
  for(Iterator<Element> i2 = c2.iterator(); i.hasNext(); ) {
    Element e2 = i2.next();
    ... // Do something with e2 and i2
  }
  ```

  ​	**如果使用for循环，犯这种“剪切-粘贴”错误的可能性就会大大降低，因为通常没有必要在两个循环中使用不同的变量名**。循环是完全独立的，所以重用元素(或者迭代器)变量的名称不会有任何危害。实际上，这也是很流行的做法。

  ​	使用fαr循环与使用whie循环相比还有另外一个优势：更简短，从而增强了可读性。

  ​	下面是另外一种对局部变量的作用域进行最小化的循环做法：

  ```java
  for (int i = 0, n = expensiveComputation(); i < n; i++) {
    ... // Do something with i;
  }
  ```

  ​	关于这种做法要关注的重点是，它具有两个循环变量i和n，二者具有完全相同的作用域。第二个变量n被用来保存第一个变量的极限值，从而避免在每次迭代中执行冗余计算。通常，如果循环测试中涉及方法调用，并且可以保证在每次迭代中都会返回同样的结果，就应该使用这种做法。

  ​	**最后一种“将局部变量的作用域最小化”的方法是使方法小而集中**。如果把两个操作(activity)合并到同一个方法中，与其中一个操作相关的局部变量就有可能会出现在执行另个操作的代码范围之内。为了防止这种情况发生，只需将这个方法分成两个：每个操作用个方法来完成。

## E58 for-each循环优先于传统的for循环

+ 概述

  ​	如（E45）所述，有些任务最好结合 Stream来完成，有些最好结合迭代完成。下面是用个传统的for循环遍历集合的例子：

  ```java
  // Not the best way to iterate over a collection!
  for (Iterator<Element> i = c.iterator(); i.hasNext(); ){
  	Element e = i.next();
    ... // Do something with e
  }
  ```

  ​	用传统的for循环遍历数组的做法如下：

  ```java
  // Not the best way to iterate over an array!
  for (int i = 0; i < a.length; i++) {
    ... // Do something with a[i]
  }
  ```

  ​	这些做法都比while循环(详见第57条)更好，但是它们并不完美。迭代器和索引变量都会造成一些混乱——而你需要的只是元素而已。而且，它们也代表着出错的可能。迭代器在每个循环中出现三次，索引变量在每个循环中出现四次，其中有两次让你很容易出错。旦出错，就无法保证编译器能够发现错误。最后一点是，这两个循环是截然不同的，容器的类型转移了不必要的注意力，并且为修改该类型增加了一些困难。

  ​	for-each循环(官方称之为“增强的for语句”)解决了所有问题。通过完全隐藏迭代器或者索引变量，避免了混乱和出错的可能。这种模式同样适用于集合和数组，同时简化了将容器的实现类型从一种转换到另一种的过程：

  ```java
  // The preferred idiom for iterating over collections and arrays
  for (Element e : elements) {
    ... // Do something with e
  }
  ```

  ​	当见到冒号(:)时，可以把它读作“在……里面”。因此上面的循环可以读作“对于元素elements中的每一个元素e”。注意，利用 for-each循环不会有性能损失，甚至用于数组也样：它们产生的代码本质上与手工编写的一样。

  ​	对于嵌套式迭代，for-each循环相对于传统for循环的优势还会更加明显。下面就是人们在试图对两个集合进行嵌套迭代时经常会犯的错误：

  ```java
  // Can you spot the bug?
  enum Suit { CLUB, DIAMOND, HEART, SPADE }
  enum Rank { ACE, DUECE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NIGHT, TEN, JACK, QUEEN, KING }
  ...
  static Collection<Suit> suits = Arrays.asList(Suit.values());
  static Collection<Rank> ranks = Arrays.asList(Rank.values());
  
  List<Card> deck = new ArrayList<>();
  for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
    for(Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
      deck.add(new Card(i.next(), j.next()));
  ```

  ​	如果之前没有发现这个Bug也不必难过。许多专家级的程序员偶尔也会犯这样的错误。问题在于，在迭代器上对外部的集合(suits)调用了太多次next方法。它应该从外部的循环进行调用，以便每种花色调用一次，但它却是从内部循环调用，因此每张牌调用一次。在用完所有花色之后，循环就会抛出 NoSuchElementException异常。

  ​	如果真的那么不幸，并且外部集合的大小是内部集合大小的几倍(可能因为它们是相同的集合)，循环就会正常终止，但是不会完成你想要的工作。例如，下面就是一个考虑不周的尝试，想要打印一对骰子的所有可能的滚法：

  ```java
  // Same bug, different symptom!
  enum Face { ONE, TWO, THREE, FOUR, FIVE, SIX }
  ...
  Collection<Face> faces = EnumSet.allOf(Face.class);
  
  for(Iterator<Face> i = faces.iterator(); i.hasNext(); )
    for(Iterator<Face> j = faces.iterator(); j.hasNext(); )
      System.out.println(i.next() + " " + j.next());
  ```

  ​	这个程序不会抛出异常，而是只打印6个重复的词(从“ ONE ONE”到“ SIX SIX”)，而不是预计的那36种组合。

  ​	为了修正这些示例中的Bug，必须在外部循环的作用域中添加一个变量来保存外部元素:

  ```java
  // Fixed, but ugly - you can do better!
  for(Iterator<Suit> i = suits.iterator(); i.hasNext(); ) {
    Suit suit = i.next();
    for(Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
      deck.add(new Card(suit, j.next()));
  }
  ```

  ​	如果使用的是嵌套式 for-each循环，这个问题就会完全消失。产生的代码将如你所希望的那样简洁:

  ```java
  // Preferred idiom for nested iteration on collections and arrays
  for(Suit suit : suits)
    for(Rank rank : ranks)
      deck.add(new Card(suit, rank));
  ```

  ​	遗憾的是，有<u>三种常见的情况无法使用for-each循环</u>：

  + 解构过滤——如果需要遍历集合，并删除选定的元素，就需要使用显式的迭代器，以便可以调用它的 remove方法。**使用Java8中增加的Collection的removeIf方法，常常可以避免显式的遍历**。
  + 转换——如果需要遍历列表或者数组，并取代它的部分或者全部元素值，就需要列表迭代器或者数组索引，以便设定元素的值。
  + 平行迭代——如果需要并行地遍历多个集合，就需要显式地控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以同步前进(就如上述有问题的牌和骰子的示例中无意间所示范的那样)。

  ​	如果你发现自己处于以上任何一种情况之下，就要使用普通的for循环，并且要警惕本条目中提到的陷阱。**for-each循环不仅能遍历集合和数组，还能遍历实现Iterable接口的任何对象**，该接口中只包含单个方法，具体如下：

  ```java
  public interface Iterable<E> {
    // Returns an iterator over the elements in this iterable
    Iterator<E> iterator();
  }
  ```

  ​	**如果不得不从头开始编写自己的Iterator实现，其中还是有些技巧的，但是如果编写的是表示一组元素的类型，则应该坚决考虑让它实现Iterable接口，甚至可以选择让它不要实现Collection接口**。这样，你的用户就可以利用for-each循环遍历类型，他们会永远心怀感激的。

---

+ 小结

  ​	总而言之，与传统的for循环相比，for-each循环在简洁性、灵活性以及出错预防性方面都占有绝对优势，并且没有性能惩罚的问题。因此，当可以选择的时候，for-each循环应该优先于for循环。

## E59 了解和使用类库

+ 概述

  ​	假设你希望产生位于0和某个上界之间的随机整数。面对这个常见的任务，许多程序员会编写出如下所示的方法：

  ```java
  // Common but deeply flawed!
  static Random rnd = new Random();
  static int random(int n) {
    return Math.abs(rnd.nextInt()) % n;
  }
  ```

  ​	这个方法看起来可能不错，但是却有三个缺点。第一个缺点是，如果n是一个比较小的2的乘方，经过一段相当短的周期之后，它产生的随机数序列将会重复。第二个缺点是如果n不是2的乘方，那么平均起来，有些数会比其他的数出现得更为频繁。如果n比较大，这个缺点就会非常明显。这可以通过下面的程序直观地体现出来，它会产生100万个经过精心指定的范围内的随机数，并打印出有多少个数字落在随机数取值范围的前半部分：

  ```java
  public static void main(String[] args) {
    int n = 2 * (Integer.MAX_VALUE / 3);
    int low = 0;
    for (int i = 0; i < 1000000; i++)
      if(random(n) < n/2)
        low++;
    System.out.println(low);
  }
  ```

  ​	如果 random方法工作正常，这个程序打印出来的数将接近于100万的一半，但是如果真正运行这个程序，就会发现它打印出来的数接近于66666。由random方法产生的数字有三分之二落在随机数取值范围的前半部分。

  ​	random方法的第三个缺点是，在极少数情况下，它的失败是灾难性的，因为会返回一个落在指定范围之外的数。之所以如此，是因为这个方法试图通过调用`Math.abs`，将`rnd.nextInt()`返回的值映射为一个非负整数int。如果`nexInt()`返回`Integer.MIN_VALUE`，那么`Math.abs`也会返回`Integer. MIN_VALUE`，假设n不是2的乘方，那么取模操作符(%)将返回一个负数。这几乎肯定会使程序失败，而且这种失败很难重现。

  ​	为了编写能修正这三个缺点的random方法，有必要了解关于同余伪随机数生成器、数论和2的求补算法的相关知识。幸运的是，你并不需要自己来做这些工作——已经有现成的成果可以为你所用。这一成果被称作 `Random.nextInt(int)`。你无须关心`nextInt(int)`的实现细节(如果你有强烈的好奇心，可以研究它的文档或者源代码)。具有算法背景的高级工程师已经花了大量的时间来设计、实现和测试这个方法，然后经过这个领域中的专家的审查，以确保它的正确性。之后，标准类库经过了Beta测试并正式发行，几年之间已经有成千上万的程序员在使用它。在这个方法中还没有发现过缺陷，但是，如果将来发现有缺陷，在下一个发行版本中就会修正这些缺陷。**通过使用标准类库，可以充分利用这些编写标准类库的专家的知识，以及在你之前的其他人的使用经验**。

  ​	从Java7开始，就不应该再使用Random了。**现在选择随机数生成器时，大多使用ThreadLocalRandom**。它会产生更高质量的随机数，并且速度非常快。在作者的机器上，比 Random快了3.6倍。<u>对于 Fork Join pool和并行Stream，则使用SplittableRandom</u>。

  ​	使用标准类库的第二个好处是，不必浪费时间为那些与工作不太相关的问题提供特别的解决方案。就像大多数程序员一样，应该把时间花在应用程序上，而不是底层的细节上。

  ​	使用标准类库的第三个好处是，它们的性能往往会随着时间的推移而不断提高，无须你做任何努力。因为许多人在使用它们，并且是当作工业标准在使用，所以提供这些标准类库的组织有强烈的动机要使它们运行得更快。这些年来，许多Java平台类库已经被重新编写了，有时候是重复编写，从而在性能上有了显著的提高。

  ​	使用标准类库的第四个好处是，它们会随着时间的推移而增加新的功能。如果类库中漏掉了某些功能，开发者社区就会把这些缺点公示出来，漏掉的功能就会添加到后续的发行版本中。

  ​	使用标准类库的最后一个好处是，可以使自己的代码融入主流。这样的代码更易读更易维护、更易被大多数的开发人员重用。

  ​	既然有那么多的优点，使用标准类库机制而不选择专门的实现，这显然是符合逻辑的，然而还是有相当一部分的程序员没有这样做。为什么呢?可能他们并不知道有这些类库机制的存在。**在每个重要的发行版本中，都会有许多新的特性被加入到类库中，所以与这些新特性保持同步是值得的**。每当Java平台有重要的发行时，都会发布一个网页来说明新的特性。这些网页值得好好读一读[Java8-feat，Java9-feat]。举个例子，假设想要编写一个程序，用它打印出命令行中指定的一条URL的内容( Linux中curl命令的作用大体如此)。在Java9之前，这些代码有点烦琐，但是Java9在 InputStream中增加了 transferTo方法。下面就是利用这个新方法完成这项任务的完整程序：

  ```java
  // Printing the contents of a URL with transferTo, added in Java9
  public static void main(String[] args) throws IOException {
    try (InputStream in = new URL(args[0]).openStream()) {
      in.transferTo(System.out);
    }
  }
  ```

  ​	这些标准类库太庞大了，以至于不可能学完所有的文档Java9-api]，但是**每个程序员都应该熟悉java.lang、java.util、java.io及其子包中的内容**。关于其他类库的知识可以根据需要随时学习。总结类库中的机制超出了本条目的范围，几年来它们已经发展得十分庞大了。

  ​	其中有几个类库值得一提。 Collections Framework(集合框架)和 Stream类库(详见E45至E48)应该成为每一位程序员基本工具箱中的一部分，同样也应该成为java.util.concurrent中并发机制的组成部分。这个包既包含高级的并发工具来简化多线程的编程任务，还包含低级别的并发基本类型，允许专家们自己编写更高级的并发抽象。关于java.util. concurrent的高级部分，请参阅（E80）和（E81）。

  ​	在某些情况下，一个类库工具并不能满足你的需要。你的需求越是特殊，这种情形就越有可能发生。虽然你的第一个念头应该是使用标准类库，但是，如果你在观察了它们在某些领域所提供的功能之后，确定它不能满足需要，你就得使用其他的实现。任何一组类库所提供的功能总是难免会有遗漏。如果你在Java类库中找不到所需要的功能，下一个选择应该是在高级的第三方类库中去寻找，比如 Google优秀的开源 Guava类库[Guava]。如果在所有相应的类库中都无法找到你所需的功能，就只能自己实现这些功能了。

---

+ 小结

  ​	总而言之，不要重复发明轮子。如果你要做的事情看起来是十分常见的，有可能类库中已经有某个类完成了这样的工作。如果确实是这样，就使用现成的；如果还不清楚是否存在这样的类，就去查一查。

  ​	一般而言，类库的代码可能比你自己编写的代码更好一些，并且会随着时间的推移而不断改进。这并不是在质疑你作为一个程序员的能力。

  ​	<u>从经济角度的分析表明：类库代码受到的关注远远超过大多数普通程序员在同样的功能上所能给予的投入</u>。

## E60 如果需要精确的答案，请避免使用float和double

+ 概述

  ​	float和double类型主要是为了科学计算和工程计算而设计的。它们执行二进制浮点运算(binary floating-point arithmetic)，这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们并没有提供完全精确的结果，所以不应该被用于需要精确结果的场合。**float和double类型尤其不适合用于货币计算**，因为<u>要让一个float或者double精确地表示0.1(或者10的任何其他负数次方值)是不可能的</u>。

  ​	**需要严格精确计算的场景，应该用BigDecimal、int或者long。（比如货币计算）**

  ​	然而，使用 BigDecimal有两个缺点：与使用基本运算类型相比，这样做很不方便，而且速度很慢。对于解决这样一个简单的问题，后一种缺点并不要紧，但是前一种缺点可能会让你很不舒服。

  ​	<u>除了使用BigDecimal之外，还有一种办法是使用int或者long，到底选用int还是long要取决于所涉及数值的大小，同时要自己处理十进制小数点</u>。

---

- 小结

  ​	总而言之，对于任何需要精确答案的计算任务，请不要使用float或者double。如果你想让系统来处理十进制小数点，并且不介意因为不使用基本类型而带来的不便，就请使用BigDecimal。使用 BigDecimal还有一些额外的好处，它允许你完全控制舍入，每当个操作涉及舍入的时候，你都可以从8种舍入模式中选择其一。如果你正通过合法强制的舍入行为进行商务计算，使用 Bigdecimal是非常方便的。

  + 如果性能非常关键，并且你又不介意自己处理十进制小数点，而且所涉及的数值又不太大，就可以使用int或者long。

  + 如果数值范围没有超过9位十进制数字，就可以使用int;如果不超过18位数字，就可以使用long。

  + 如果数值可能超过18位数字，就必须使用BigDecimal。

## E61 基本类型优先于装箱基本类型

+ 概述

  ​	Java有一个类型系统由两部分组成，它包含基本类型(primitive)，如int、 double和boolean，以及引用类型(reference type)，如 String和List。每个基本类型都有一个对应的引用类型，称作装箱基本类型(boxed primitive)。装箱基本类型中对应于int、 double和boolean的分别是Integer、Double和Boolean。

  ​	如第6条中提到的，自动装箱(autoboxing)和自动拆箱(auto-unboxing)模糊了但并没有完全抹去基本类型和装箱基本类型之间的区别。这两种类型之间真正是有差别的，要很清楚在使用的是哪种类型，并且要对这两种类型进行谨慎的选择，这些都非常重要。

  ​	在基本类型和装箱基本类型之间有三个主要区别。

  + 第一，基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。换句话说，<u>两个装箱基本类型可以具有相同的值和不同的同一性</u>。
  + 第二，基本类型只有函数值，而每个装箱基本类型则都有一个非函数值，除了它对应基本类型的所有函数值之外，还有个null。
  + 最后一点区别是，基本类型通常比装箱基本类型更节省吋间和空间。

  ​	如果不小心，这三点区别都会让你陷入麻烦之中。

  ​	以下面这个比较器为例，它被设计用来表示Integer值的递增数字顺序。（回想一下，比较器的compare方法返回的数值到底为负数、零还是正数，要取决于它的第一个参数是小于、等于还是大于它的第二个参数。）在实践中并不需要你编写这个在Integer中实现自然顺序的比较器，因为这是不需要比较器就可以得到的，但它展示了一个有趣的例子：

  ```java
  // Broken comparator - can you spot the flaw?
  Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
  ```

  ​	这个比较器表面看起来似乎不错，它可以通过许多测试。例如，它可以通过`Collections.sort`正确地给一个有100万个元素的列表进行排序，无论这个列表中是否包含重复的元素。但是这个比较器有着严重的缺陷。如果你要让自已信服，只要打印`naturalOrder.Compare(new Integer(42)， new Integer(42))`的值便可以分晓。**这两个 Integer实例都表示相同的值(42)，因此这个表达式的值应该为0，但它输出的却是1，这表明第个Integer值大于第二个**。

  ​	问题出在哪呢? naturalOrder中的第一个测试工作得很好。**对表达式`i<j`执行计算会导致被ⅰ和j引用的Integer实例被自动拆箱(auto-unboxed)**；也就是说，它提取了它们的基本类型值。计算动作要检查产生的第一个int值是否小于第二个。但是假设答案是否定的。**下一个测试就是执行计算表达式`i==j`，它在两个对象引用上执行同一性比较(dentity comparison)**。如果i和j引用表示同一个int值的不同的Integer实例，这个比较操作就会返回false，比较器会错误地返回1，表示第一个 Integer值大于第二个。**对装箱基本类型运用==操作符几乎总是错误的**。

  ​	事实上，如果需要用比较器描述一个类型的自然顺序，只要调用`Comparator.naturalOrder()`即可，如果自己编写比较器，则应该使用比较器构造方法，或者在基本类型上使用静态比较方法（E14）。也就是说，修正这个问題的做法是添加两个局部变量，来保存对应于装箱 Integer参数的基本类型int值，并在这些变量上执行所有的比较操作。这样可以避免大量的同一性比较：

  ```java
  Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed; // Auto-unboxing
    return i < j ? -1 : (i == j ? 0 : 1);
  }
  ```

  ​	接下来，看如下程序：

  ```java
  public class Unbelievable {
    static Integer i;
    public static void main(String[] args) {
      if (i == 42)
        System.out.println("Unbelievable");
    }
  }
  ```

  ​	**它不会打印出Unbelievable——但是它的行为也是很奇怪的。它在计算表达式`(i==42)`的时候抛出NullPointerException异常**。问题在于，i是个Integer，而不是int，就像所有的对象引用域一样，它的初始值为null。当程序计算表达式`(i==42)`时，它会将 Integer与int进行比较。

  ​	<u>几乎在任何一种情况下，**当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱**，这种情况无一例外。如果null对象引用被自动拆箱，就会抛出一个NullPointerException异常</u>。就如这个程序所示，它几乎可以在任何位置发生。修正这个问题很简单，声明i是个int而不是 Integer即可。

  ​	最后，以（E6）中的这个程序为例：

  ```java
  // Hideously slow program! Can you spot the object creation?
  public static void main(String[] args) {
    Long sum = 0L;
    for (long i = 0; i < Integer.MAX_VALUE; i++) {
      sum += i;
    }
    System.out.println(sum);
  }
  ```

  ​	这个程序运行起来比预计的要慢一些，因为它不小心将一个局部变量(sum)声明为是装箱基本类型Long，而不是基本类型long。程序编译起来没有错误或者警告，变量被反复地装箱和拆箱，导致明显的性能下降。

  ​	在本条目中所讨论的这三个程序中，问题是一样的：程序员忽略了基本类型和装箱基本类型之间的区别，并尝到了苦头。在前两个程序中，其结果是彻底的失败；在第三个程序中，则有严重的性能问题。

  ​	那么什么时候应该使用装箱基本类型呢？它们有几个合理的用处。第一个是作为集合中的元素、键和值。你不能将基本类型放在集合中，因此必须使用装箱基本类型。这是一种更通用的特例。在参数化类型和方法(详见第5章)中，必须使用装箱基本类型作为类型参数，因为Java不允许使用基本类型。例如，你不能将变量声明为`ThreadLocal<int>`类型，因此必须使用`Threadlocal<Integer>`代替。最后，在进行反射的方法调用（E65）时，必须使用装箱基本类型。

---

+ 小结

  ​	总而言之，当可以选择的时候，基本类型要优先于装箱基本类型。基本类型更加简单，也更加快速。如果必须使用装箱基本类型，要特别小心！

  + **自动装箱减少了使用装箱基本类型的烦琐性，但是并没有减少它的风险**。
  + 当程序用`==`操作符比较两个装箱基本类型时，它做了个同一性比较，这几乎肯定不是你所希望的。
  + **当程序进行涉及装箱和拆箱基本类型的混合类型计算时，它会进行拆箱，当程序进行拆箱时，会抛出NullPointerException异常**。
  + 最后，<u>当程序装箱了基本类型值时，会导致较高的资源消耗和不必要的对象创建</u>。

## E62 如果其他类型更适合，则尽量避免使用字符串

+ 概述

  ​	字符串被用来表示文本，它在这方面也确实做得很好。因为字符串很通用，并且Java语言也支持得很好，所以自然就会有这样一种倾向：即使在不适合使用字符串的场合，人们往往也会使用字符串。本条目就是讨论一些不应该使用字符串的情形。

  ​	**字符串不适合代替其他的值类型**。当一段数据从文件、网络，或者键盘设备，进入程序之后，它通常以字符串的形式存在。有一种自然的倾向是让它继续保留这种形式，但是只有当这段数据本质上确实是文本信息时，这种想法才是合理的。如果它是数值，就应该被转换为适当的数值类型，比如int、foat或者BigInteger类型。如果它是个“是-或否”这种问题的答案，就应该被转换为 boolean类型。如果存在适当的值类型，不管是基本类型，还是对象引用，大多应该使用这种类型；如果不存在这样的类型，就应该编写一个类型。虽然这条建议是显而易见的，但通常未能得到遵守。

  ​	**字符串不适合代替枚举类型**。正如（E34）中所讨论的，枚举类型比字符串更加适合用来表示枚举类型的常量。

  ​	**字符串不适合代替聚合类型**。如果一个实体有多个组件，用一个字符串来表示这个实体通常是很不恰当的。例如，下面这行代码来自于真实的系统—标识符的名称已经被修改了，以免发生纠纷：

  ```java
  // Inappropriate use of string as aggregate type
  String compoundKey = className + "#" + i.next();
  ```

  ​	这种方法有许多缺点。如果用来分隔域的字符也出现在某个域中，结果就会出现混乱。为了访问单独的域，必须解析该字符串，这个过程非常慢，也很烦琐，还容易出错。你无法提供 equals、 toString或者 compareTo方法，只好被迫接受String提供的行为。更好的做法是，简单地编写一个类来描述这个数据集，通常是一个私有的静态成员类(详见E24)。

  ​	**字符串也不适合代替能力表(capabilities)**。有时候，字符串被用于对某种功能进行授权访问。例如，考虑设计一个提供线程局部变量(thread-local variable)的机制。这个机制提供的变量在每个线程中都有自己的值。自Java1.2发行版本以来，Java类库就有提供线程局部变量的机制，但在那之前，程序员必须自己完成。几年前，面对这样的设计任务时，有些人提出了同样的设计方案：利用客户提供的字符串键对每个线程局部变量的内容进行访问授权：

  ```java
  // Broken - inappropriate use of string as capability!
  public class ThreadLocal {
    private ThreadLocal() { } // Nonistantiable
    
    // Sets the current thread's value for the named variable.
    public static void set(String key, Object value);
    
    // Returns the current thread's value for the named variable.
    public static Object get(String key);
  }
  ```

  ​	这种方法的问题在于，这些字符串键代表了一个共享的全局命名空间。要使这种方法可行，客户端提供的字符串键必须是唯一的：如果两个客户端各自决定为它们的线程局部变量使用同样的名称，它们实际上就无意中共享了这个变量，这样往往会导致两个客户端都失败，而且安全性也很差。恶意的客户端可能有意地使用与另一个客户端相同的键，以便非法地访问其他客户端的数据。

  ​	要修正这个API并不难，只要用一个不可伪造的键(有时被称为能力)来代替字符串即可:

  ```java
  public class ThreadLocal {
    private ThreadLocal() { } // Noninstantiable
    
    public static class Key { // (Capability)
      Key() { }
    }
    
    // Generates a unique, unforgeable key
    public static Key getKey() {
      return new Key();
    }
    
    public static void set(Key key, Object value);
    public static Object get(Key key);
  }
  ```

  ​	这样虽然解决了基于字符串的API的两个问题，但是你还可以做得更好。你实际上不再需要静态方法，它们可以被代之以键(Key)中的实例方法，这样这个键就不再是键，而是线程局部变量了。此时，这个不可被实例化的顶层类也不再做任何实质性的工作，因此可以删除这个顶层类，并将嵌套类命名为 ThreadLocal：

  ```java
  public final class ThreadLocal {
    public ThreadLocal();
    public void set(Object value);
    public Object get();
   }
  ```

  ​	这个API不是类型安全的，因为当你从线程局部变量得到它时，必须将值从Object转换成它实际的值。不可能使原始的基于String的API为类型安全的，要使基于Key的API为类型安全的也很困难，但是通过将 ThreadLocal类泛型化（E29），使这个API变成类型安全的就是很简单的事情了：

  ```java
  public final class ThreadLocal<T> {
    public ThreadLocal();
    public void set(T value);
    public T get();
  }
  ```

  ​	粗略地讲，这正是`java.lang. ThreadLocal`提供的API。除了解决了基于字符串的API的问题之外，与前面的两个基于键的API相比，它还更快速、更美观。

---

+ 小结

  ​	总而言之，如果可以使用更加合适的数据类型，或者可以编写更加适当的数据类型，就应该避免用字符串来表示对象。若使用不当，字符串会比其他的类型更加笨拙、更不灵活、速度更慢，也更容易出错。

  ​	经常被错误地用字符串来代替的类型包括基本类型、枚举类型和聚合类型。

## E63 了解字符串连接的性能

+ 概述

  ​	<u>字符串连接操作符(+)是把多个字符串合并为一个字符串的便利途径。要想产生单独行的输出，或者构造一个字符串来表示一个较小的、大小固定的对象，使用连接操作符是非常合适的，但是它不适合运用在大规模的场景中。**为连接n个字符串而重复地使用字符串连接操作符，需要n的平方级的时间**。这是由于字符串不可变（E17）而导致的不幸结果。当两个字符串被连接在一起时，它们的内容都要被拷贝</u>。

  ​	例如，下面的方法通过重复地为每个项目连接一行，构造出一个代表该账单声明的字符串:

  ```java
  // Inappropriate use of string concatenation - Performs poorly!
  public String statement() {
    String result = "";
    for (int i = 0; j < numItems(); i++)
      result += lineForItem(i); // String concatenation
    return result;
  }
  ```

  ​	如果项目的数量巨大，这个方法的执行时间就难以估算。**为了获得可以接受的性能，请用StringBuilder代替String**，来存储构造过程中的账单声明：

  ```java
  public String statement() {
    StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH);
    for (int i = 0; i < numItems(); i++)
      b.append(lineForItem(i));
    return b.toString();
  }
  ```

  ​	从Java6以来，已经做了大量的工作使字符串连接变得更加快速，但是上述两种做法的性能差别还是很大：如果numItems返回100，并且lineForItem返回一个固定长度为80个字符的字符串，在作者的机器上，第二种做法比第一种做法要快6.5倍。因为第一种做法的开销随项目数量而呈平方级增加，项目的数量越大，性能的差别就会越明显。注意，第二种做法预先分配了一个 StringBuilder，使它大到足以容纳整个结果字符串，因此<u>不需要自动扩展</u>。即使使用了默认大小的StringBuilder，它也仍然比第一种做法快5.5倍。

  ​	原则很简单：**不要使用字符串连接操作符来合并多个字符串**，除非性能无关紧要。否则，应该使用 StringBuilder的append方法。另一种做法是使用字符数组，或者每次只处理一个字符串，而不是将它们组合起来。

## * E64 通过接口引用对象

+ 概述

  ​	第51条建议：应该使用接口而不是类作为参数类型。更通俗来讲，应该优先使用接口而不是类来引用对象。**如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明**。只有当你利用构造器创建某个对象的时候，才真正需要引用这个对象的类。为了更具体地说明这一点，以 LinkedHashSet的情形为例，它是Set接口的一个实现。在声明变量的时候应该养成这样的习惯：

  ```java
  // Good - uses interface as type
  Set<Son> sonSet = new LinkedHashSet<>();
  ```

  ​	而不是像这样的声明：

  ```java
  // Bad - uses class as type!
  LinkedHasSet<Son> sonSet = new LinkedHashSet<>();
  ```

  ​	**如果养成了用接口作为类型的习惯，程序将会更加灵活**。当你决定更换实现时，所要做的就只是改变构造器中类的名称(或者使用一个不同的静态工厂)。例如，第一个声明可以被改变为：

  ```java
  Set<Son> sonSet = new HashSet<>();
  ```

  ​	周围的所有代码都可以继续工作。周围的代码并不知道原来的实现类型，所以它们对于这种变化并不在意。	有一点值得注意：<u>如果原来的实现提供了某种特殊的功能，而这种功能并不是这个接口的通用约定所要求的，并且周围的代码又依赖于这种功能，那么很关键的一点是，新的实现也要提供同样的功能。</u>

  ​	例如，如果第一个声明周围的代码依赖于 LinkedHashSet的同步策略，那么在声明中用HashSet代替LinkedHashSet就是不正确的，因为 HashSet不能保证相关的迭代顺序。

  ​	为什么要改变实现类型呢？因为第二个实现提供了比第一个更好的性能，或者因为它提供了你所期待的而原来的实现缺乏的功能。

  ​	比如，假设有一个域中包含了一个 HashMap实例。如果将它改成 EnumMap，则可以提供更好的性能，并且迭代顺序与键的自然顺序一致但是如果键的类型为枚举类型，你就只能使用EnumMap。如果将HashMap改成 LinkedHashMap，则能提供可以预估的迭代顺序，以及可以与HashMap比拟的性能，对于键类型没有任何特殊的要求。

  ​	你可能会觉得，用变量的实现类型来声明变量，也是可以接受，因为可以同时改变声明类型和实现类型，但是不能确保修改后的程序可以编译。如果客户端代码使用了没有出现在新实现中的原始实现类型中的方法，或者客户端代码将该实例传到了需要原始实现类型的方法中，那么代码在完成这样的修改之后将不再进行编译。用接口类型声明变量要“保持诚实”。

  ​	<u>**如果没有合适的接口存在，完全可以用类而不是接口来引用对象**。以值类(value class)为例，比如String和 BigInteger。记住，值类很少会用多个实现编写。它们经常是final的，并且很少有对应的接口。使用这种值类作为参数、变量、域或者返回类型是再合适不过的了</u>。

  ​	不存在适当接口类型的第二种情形是，对象属于一个框架，而框架的基本类型是类，不是接口。如果对象属于这种基于类的框架(class-based framework)，就应该用相关的基类(base class)(往往是抽象类)来引用这个对象，而不是用它的实现类。许多`java.io`类，比如`OutputStream`就属于这种情形。
  ​	不存在适当接口类型的最后一种情形是，类实现了接口但它也提供了接口中不存在的额外方法——例如 PriorityQueue有一个没有出现在Queue接口中的comparator方法。如果程序依赖于这些额外的方法，这种类就应该只被用来引用它的实例，永远也不应该被用作参数类型。

  ​	以上这些例子并不全面，而只是代表了一些“适合于用类来引用对象”的情形。实际上，给定的对象是否具有适当的接口应该是很显然的。如果是，用接口引用对象就会使程序更加灵活。**<u>如果没有适合的接口，就用类层次结构中提供了必要功能的最小的具体类来引用对象吧</u>**。

## E65 接口优先于反射机制

+ 概述

  ​	**核心反射机制(core reflection facility)，`java.lang.reflect`包，提供了“通过程序来访问任意类”的能力**。给定一个Class对象，可以获得Constructor、 Method和Field实例，它们分别代表了该Class实例所表示的类的构造器、方法和域。这些对象提供了“通过程序来访问类的成员名称、域类型、方法签名等信息”的能力。

  ​	此外， Constructor、 Method和Field实例使你能够通过反射机制操作它们的底层对等体：通过调用 Constructor、 Method和Field实例上的方法，可以构造底层类的实例、调用底层类的方法，并访问底层类中的域。例如， `Method.invoke`使你可以调用任何类的任何对象上的任何方法(遵从常规的安全限制)。<u>反射机制允许一个类使用另一个类，即使当前者被编译的时候后者还根本不存在</u>。然而，这种能力也要付出代价：

  + **损失了编译时类型检查的优势，包括异常检查**。如果程序企图用反射方式调用不存在的或者不可访问的方法，在运行时它将会失败，除非采取了特别的预防措施。
  + **执行反射访问所需要的代码非常笨拙和冗长**。编写这样的代码非常乏味，阅读起来也很困难。
  + **性能损失**。反射方法调用比普通方法调用慢了许多。具体慢了多少，这很难说，因为受到了多个因素的影响。在作者的机器上，调用一个没有输入参数和int返回值的方法，用普通方法调用比用反射机制调用快了11倍。

  ​	有一些复杂的应用程序需要使用反射机制。这些示例包括代码分析工具和依赖注入框架。不过最近以来，这类工具已经不再使用反射机制，因为它的缺点越来越明显。<u>如果你怀疑自己的应用程序是否也需要反射机制，它很有可能是不需要的</u>。

  ​	**如果只是以非常有限的形式使用反射机制，虽然也要付出少许代价，但是可以获得许多好处**。许多程序必须用到的类在编译时是不可用的，但是在编译时存在适当的接口或者超类，通过它们可以引用这个类(E64)。如果是这种情况，就可以**用反射方式创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例**。

  ​	例如，下面的程序创建了一个`Set<String>`实例，它的类是由第一个命令行参数指定的。该程序把其余的命令行参数插入到这个集合中，然后打印该集合。不管第一个参数是什么，程序都会打印出余下的命令行参数，其中重复的参数会被消除掉。这些参数的打印顺序取决于第一个参数中指定的类。如果指定`java.util. HashSet`，显然这些参数就会以随机的顺序打印出来；如果指定`java.util. TreeSet`，则会按照字母顺序打印，因为TreeSet中的元素是排好序的。相应的代码如下：

  ```java
  // Reflective instantiation with interface access
  public static void main(String[] args) {
    // Translate the class name into a Class object
    Class<? extends Set<String>> cl = null;
    try {
      cl = (Class<? extends Set<String>>) Class.forName(args[0]);// Unchecked cast!
    } catch (ClassNotFoundException e) {
      fatalError("Class not found.");
    }
    // Get the constructor
    Constructor<? extends Set<String>> cons = null;
    try {
      cons = cl.getDeclaredConstructor();
    } catch (NoSuchMethodException e) {
      fatalError("No parameterless constructor");
    }
    // Instantiate the set
    Set<String> s = null;
    try {
      s = cons.newInstance();
    } catch (IllegalAccessException e) {
      fatalError("Constructor not accessible");
    } catch (InstantiationException e) {
      fatalError("Class not instantiable.");
    } catch (InvocationTargetException e) {
      fatalError("Constructor threw " + e.getCause());
    } catch (ClassCastException e) {
      fatalError("Class doesn't implement Set");
    }
    // Exercise the set
    s.addAll(Arrays.asList(args).subList(1, args.length));
    System.out.println(s);
  }
  private static void fatalError(String msg) {
    System.err.println(msg);
    System.exit(1);
  }
  ```

  ​	尽管这只是一个试验程序，但是它所演示的方法是非常强大的。这个试验程序可以很容易地变成一个通用的集合测试器，通过侵入式地操作一个或者多个集合实例，并检查是否遵守Set接口的约定，以此来验证指定的Set实现。同样地，它也可以变成一个通用的集合性能分析工具。<u>实际上，它所演示的这种方法足以实现一个成熟的服务提供者框架(service provider framework)，详见（E1）。绝大多数情况下，使用反射机制时需要的也正是这种方法</u>。

  ​	这个示例演示了反射机制的两个缺点。

  + 第一，这个例子会产生6个运行时异常，如果不使用反射方式的实例化，这6个错误都会成为编译时错误。(为了好玩，你也可以通过传入适当的命令行参数，让程序逐个生成这6个异常。)
  + 第二，根据类名生成其实例需要25行冗长的代码，而调用一个构造器则可以非常简洁地只用一行代码。程序的长度可以通过捕捉ReflectiveOperationException异常来减少，这是在Java7中引入的各种反射异常的一个超类。这两个缺点都局限于实例化对象的那部分代码。一且对象被实例化，它与其他的Set实例就难以区分了。在实际的程序中，通过这种限定使用反射的方法，绝大部分代码可以不受影响。

  ​	如果试着编译这个程序，会得到一条未受检的转换警告。这条警告是合法的，因此转换`Class<? extends Set<String>>`会成功，即使具名类不是一个Set实现，在这种情况下，程序在实例化这个类时就会抛出一个 ClassCastException异常。要了解禁止这种警告的最佳方法，请参见（E27）。

  ​	<u>类对于在运行时可能不存在的其他类、方法或者域的依赖性，用反射法进行管理是合理的，但是很少使用</u>。如果要编写一个包，并且它运行的时候就必须依赖其他某个包的多个版本，这种法可能就非常有用。具体做法就是，在支持包所需要的最小环境下对它进行编译，通常是最老的版本，然后以反射方式访问任何更加新的类或者方法。<u>如果企图访问的新类或者新方法在运行时不存在，为了使这种方法有效你还必须采取适当的动作。所谓适当的动作可能包括使用某种其他可替换的办法来达到同样的目的，或者使用简化的功能进行处理</u>。

---

+ 小结

  ​	总而言之，反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的，但它也有一些缺点。<u>如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者超类</u>。

## * E66 谨慎地使用本地方法

+ 概述

  ​	<u>Java Native Interface(JNⅠ)允许Java应用程序调用本地方法(native method)，所谓本地方法是指用本地编程语言(比如C或者C++)来编写的方法。</u>

  + 它们提供了“访问特定于平台的机制”的能力，比如访问注册表(registry)。
  + 它们还提供了访问本地遗留代码库的能力，从而可以访问遗留数据(legacy data)。
  + 最后，本地方法可以通过本地语言，编写应用程序中注重性能的部分，以提高系统的性能。

  ​	<u>使用本地方法来访问特定于平台的机制是合法的，但是几乎没有必要：因为随着Java平台的不断成熟，它提供了越来越多以前只有在宿主平台上才拥有的特性</u>。

  ​	例如，Java9增加的进程API，提供了访问操作系统进程的能力。

  ​	当Java中没有相当的类库可用时，使用本地方法来使用遗留代码库也是合法的。

  ​	**<u>使用本地方法来提高性能的做法不值得提倡</u>**。在早期的发行版本中(Java3发行版本之前)，这样做往往是很有必要的，但是从那以后，JVM实现变得越来越快了。对于大多数任务，现在用Java就可以获得与之相当的性能。举例来说，当Java1.1发行版本中增加了java. math时， BigInteger是在一个用C编写的快速多精度运算库的基础上实现的。在Java3发行版本中， BigInteger则完全用Java重新实现了，并且进行了精心的性能调优，运行得比原来的本地实现更快。

  ​	这个故事有一个悲伤的尾声：从那时起， BigInteger几乎没怎么改变，但在Java8中大整数却以更快的乘积速度在发展。当时，遗留代码库的工作还在持续快速地发展中，著名的有GNU高精度算术运算库( GNU Multiple Precision，GMP)。对于需要真正高性能的高精度算术运算的Java程序员，现在通过本地方法来使用GMP也是无可厚非的[Blum14]。

---

+ 使用本地方法存在的风险
  + **使用本地方法有一些严重的缺陷。因为本地语言不是安全的（E50），所以使用本地方法的应用程序也不再能免受<u>内存</u>毁坏错误的影响**。
  + **因为本地语言是与平台相关的，<u>使用本地方法的应用程序也不再是可自由移植的</u>。使用本地方法的应用程序也更难调试**。
  + 如果不小心，**本地方法还可能降低性能，因为回收垃圾器不是自动的，甚至无法追踪本机内存(native memory)使用情况（E8）**，而且在进入和退出本地代码时，还需要相关的开销。
  + 最后一点，**需要“胶合代码”的本地方法编写起来单调乏味，并且难以阅读**。

---

+ 小结

  ​	总而言之，在使用本地方法之前务必三思。只有在极少数情况下需要使用本地方法来提高性能。如果你必须要使用本地方法来访问底层的资源，或者遗留代码库，也要尽可能少用本地代码，并且要全面进行测试。<u>本地代码中只要有一个Bug都可能破坏整个应用程序</u>。

## * E67 谨慎地进行优化

+ 概述

  ​	不要进行过早的优化（或者说不明确"优化"效果时，仅根据理论上认知判断就进行"优化"，是不可取的）。

  ​	**优化的弊大于利，特别是不成熟的优化。在优化过程中，产生的软件可能既不快速，也不正确，而且还不容易修正**。

  + **不要为了性能而牺牲合理的结构**。

    ​	**要努力编写好的程序而不是快的程序**。如果好的程序不够快，它的结构将使它可以得到优化。

    ​	**好的程序体现了信息隐藏(information hiding)的原则**：只要有可能，它们就会把设计决策集中在单个模块中，因此可以改变单个决策，而不会影响到系统的其他部分（E15）。

    ​	这并不意味着，在完成程序之前就可以忽略性能问题。**实现上的问题可以通过后期的优化而得到修正，但是，遍布全局并且限制性能的结构缺陷几乎是不可能被改正的，除非重新编写系统**。

    ​	<u>在系统完成之后再改变设计的某个基本方面，会破坏系统的结构，从而难以维护和改进。因此，必须在设计过程中考虑到性能问题。</u>

  + **要努力避免那些限制性能的设计决策**。

    ​	**当一个系统设计完成之后，其中最难以更改的组件是那些<u>指定了模块之间交互关系以及模块与外界交互关系的组件</u>**。

    ​	**在这些设计组件之中，最主要的是API、交互层(wire-level)协议以及永久数据格式**。<u>这些设计组件不仅在事后难以甚至不可能改变，而且它们都有可能对系统本该达到的性能产生严重的限制</u>。

  + **要考虑API设计决策的性能后果**。

    ​	<u>使公有的类型成为可变的，这可能会导致大量不必要的保护性拷贝（E50）</u>。

    ​	<u>同样地，在适合使用复合模式的公有类中使用继承，会把这个类与它的超类永远地束缚在一起，从而人为地限制了子类的性能（E18</u>）。

    ​	最后个例子，<u>在API中使用实现类型而不是接口，会把你束缚在一个具体的实现上，即使将来出现更快的实现你也无法使用（E64）</u>。

  ​	**API设计对于性能的影响是非常实际的**。以`Java.awt.Component`类中的 getSize方法为例。决定就是，这个注重性能的方法将返回Dimension实例，与此密切相关的决定是， Dimension实例是可变的，迫使这个方法的任何实现都必须为每个调用分配一个新的Dimension实例。尽管在现代VM上分配小对象的开销并不大，但是分配数百万个不必要的对象仍然会严重地损害性能。

  ​	在这种情况下，有几种可供选择的替换方案。理想情况下，Dimension应该是不可变的（E17）；另一种方案是，用两个方法来替换getSize方法，它们分别返回Dimension对象的单个基本组件。实际上，在Java2发行版本中，出于性能方面的原因，有两个这样的方法被加入到 Component APl中。然而，原先的客户端代码仍然可以使用getSize方法，并且仍然要承受原始API设计决策所带来的性能影响。

  ​	幸运的是，一般而言，好的API设计也会带来好的性能。**<u>为获得好的性能而对API进行包装，这是一种非常不好的想法</u>**。<u>导致你对API进行包装的性能因素可能会在平台未来的发行版本中，或者在将来的底层软件中不复存在，但是被包装的API以及由它引起的问题将永远困扰着你</u>。

  ​	一旦精心地设计了程序，并且产生了一个清晰、简明、结构良好的实现，那么就到了该考虑优化的时候了，假定此时你对于程序的性能还不满意。

  ​	回想一下 Jackson提出的两条优化原则：“不要优化”以及“(仅针对专家)还是不要优化”。他可以再增加一条：**在每次试图做优化之前和之后，要对性能进行测量**。

  ​	<u>你可能会惊讶于自己的发现。试图做的优化通常对于性能并没有明显的影响，有时候甚至会使性能变得更差</u>。主要原因在于，要猜出程序把时间花在哪些地方并不容易。你认为程序慢的地方可能并没有问题，这种情况下实际上是在浪费时间去尝试优化。<u>大多数人认为：程序把90%的时间花在10%的代码上了</u>。

  ​	**性能剖析工具有助于决定应该把优化的重心放在哪里**。这些工具可以为你提供运行时的信息，比如每个方法大致上花费了多少时间、它被调用多少次。<u>除了确定优化的重点之外，它还可以警告你是否需要改变算法。如果一个平方级(或更差)的算法潜藏在程序中，无论怎么调整和优化都很难解决问题。你必须用更有效的算法来替换原来的算法</u>。**系统中的代码越多，使用性能剖析器就显得越发重要**。这就好像要在一堆干草中寻找一根针：这堆干草越大，使用金属探测器就越有用。

  ​	**值得特别提及的另一种工具是jmh，它不是一个性能剖析器，而是微基准测试框架(microbenchmarking framework)，它提供了非并行地可见Java代码性能详情的能力[JMH]**。	

  ​	<u>在Java平台上对优化的结果进行测量，比在其他的传统平台(如C和C++)上更有必要，因为Java程序设计语言没有很强的性能模型(performance model)：各种基本操作的相对开销也没有明确定义</u>。程序员所编写的代码与CPU执行的代码之间存在“语义沟”(semantic gap)，而且这条语义沟比传统编译语言中的更大，这使得要想可靠地预测出任何优化的性能结果都非常困难。**大量流传的关于性能的说法最终都被证明为半真半假，或者根本就不正确**。

  ​	**不仅Java的性能模型未得到很好的定义，而且在不同的JVM实现，不同的发行版本以及不同的处理器中，也都各不相同**。如果将要在多个JVM实现和多种硬件平台上运行程序，很重要的一点是，需要在每个Java实现上测量优化效果。有时候，还必须在从不同JVM实现或者硬件平台上得到的性能结果之中进行权衡。

  ​	自从本条目开始编写以来的近二十年，Java软件堆栈的每一个组件都变得更加复杂，从管理器到虚拟机，再到类库，运行Java的各种硬件也得到了迅猛的发展。这些因素结合起来导致现在Java程序的性能比2001年时更难以预测了，因此对测量性能的需求也相应地增加了。

---

+ 小结

  ​	总而言之，**不要费力去编写快速的程序——应该努力编写好的程序，速度自然会随之而来**。

  ​	但**在设计系统的时候，特别是在设计API、交互层协议和永久数据格式的时候，一定要考虑性能的因素**。

  ​	**当构建完系统之后，要测量它的性能**。如果它足够快，你的任务就完成了。如果不够快，则可以在性能剖析器的帮助下，找到问题的根源，然后设法优化系统中相关的部分。第一个步骤是**检查所选择的算法：再多的低层优化也无法弥补算法的选择不当**。必要时重复这个过程，在每一次修改之后都要测量性能，直到满意为止。

## E68 遵守普遍接受的命名惯例

+ 概述

  ​	Java 平台建立了一整套很好的命名惯例（naming convention），其中有许多命名惯例包含在了《The Java Language Specification》[JLS，6.1］中。不严格地讲，这些命名惯例分为两大类：字面的（typographical）和语法的（grammatical）。

  ​	字面的命名惯例比较少，但也涉及包、类、接口、方法、域和类型变量。应该尽量不违反这些惯例，不到万不得已，千万不要违反。如果API违反了这些惯例，使用起来可能会很困难。如果实现违反了它们，可能会难以维护。在这两种情况下，违反惯例都会潜在地给使用这些代码的其他程序员带来困惑和苦恼，并且使他们做出错误的假设，造成程序出错。本条目将对这些惯例做简要的介绍。

  ​	包和模块的名称应该是层次状的，用句号分隔每个部分。每个部分都包括小写字母，极少数情况下还有数字。任何将在你的组织之外使用的包，其名称都应该以你的组织的Internet域名开头，并且顶级域名要放在前面，例如edu.cmu 、com.google 、org.eff 。标准类库和一些可选的包，其名称以java和javax 开头，它们属于这一规则的例外。用户创建的包的名称绝不能以java和javax开头。关于将Internet域名转换为包名称前缀的详细规则，请参见《The Java Language Specification》[JLS，6.1］。

  ​	包名称的其余部分应该包括一个或者多个描述该包的组成部分。这些组成部分应该比较简短，通常不超过8 个字符。鼓励使用有意义的缩写形式，例如，使用util而不是utilities 。只取首字母的缩写形式也是可以接受的，例如awt 。每个组成部分通常都应该由一个单词或者一个缩写词组成。

  ​	许多包的名称中都只有一个组成部分再加上Internet 域名。比较大的名称使用附加部分是正确的，它们的规模要求它们要被分割成一个非正式的层次结构。例如， javax.util包有着非常丰富的包层次如`javax.util.concurrent.atomic` 。这样的包通常被称为子包（subpackage），尽管Java语言并没有提供对包层次的支持。

  ​	类和接口的名称，包括枚举和注解类型的名称，都应该包括一个或者多个单词，每个单词的首字母大写，例如List 和FutureTask 。应该尽量避免用缩写，除非是一些首字母缩写和一些通用的缩写，比如max和min。对于首字母缩写，到底应该全部大写还是只有首字母大写，没有统一的说法。虽然有些程序员仍然采用全部大写的形式，但还是有人强烈支持只首字母大写：即使连续出现多个首字母缩写的形式，你仍然可以区分出一个单词的起始处和结束处。比如类名HTTPURL和HttpUrl你更愿意看到哪一个？

  ​	方法和域的名称与类和接口的名称一样，都遵守相同的字面惯例，只不过方法或者域的名称的第一个字母应该小写，例如remove 、ensureCapacity 。如果由首字母缩写组成的单词是一个方法或者域名称的第一个单词，它就应该是小写形式。

  ​	上述规则的唯一例外是"常量域"，它的名称应该包含一个或者多个大写的单词，中间用下划线符号隔开，例如VALUES 或 NEGATI VE _INFINITY 。常量域是个静态final域，它的值是不可变的。如果静态final域有基本类型，或者有不可变的引用类型（E17），它就是个常量域。例如，枚举常量是常量域。如果静态final域有个可变的引用类型，若被引用的对象是不可变的，它也仍然可以是个常量域。注意，常量域是唯一推荐使用下划线的情形。

  ​	局部变量名称的字面命名惯例与成员名称类似，只不过它也允许缩写，单个字符和短字符序列的意义取决于局部变量所在的上下文环境，例如i、denom和houseNum 。输入参数是一种特殊的局部变量。它们的命名应该比普通的局部变量更加小心，因为它们的名称是其方法文档的一个组成部分。

  ​	**类型参数名称通常由单个字母组成**。这个字母通常是以下五种类型之一： **T 表示任意的类型， E 表示集合的元素类型， K和V 表示映射的键和值类型， X表示异常**。函数的返回类型通常是R 。任何类型的序列可以是T 、U 、V 或者T1、T2 、T3 。

  ​	为了快速查阅，下表列出了字面惯例的例子。

  | 标识符类型 | 示例                                             |
  | ---------- | ------------------------------------------------ |
  | 包或者模块 | org.junit.jupiter.api, com.google.common.collect |
  | 类或者接口 | Stream, FutureTask, LinkedHashMap, HttpClient    |
  | 方法或者域 | remove, groupingBy, getCrc                       |
  | 常量域     | MIN_VALUE, NEGATIVE_INFINITY                     |
  | 局部变量   | i, denom, houseNum                               |
  | 类型参数   | T, E, K, V, X, R, U, V, T1, T2                   |

  ​	语法命名惯例比字面惯例更加灵活，也更有争议。对于包而言，没有语法命名惯例。可被实例化的类（包括枚举类型）通常用一个名词或者名词短语命名， 例如Thread 、PriorityQueue 或者ChessPiece 。不可实例化的工具类（E4）经常用复数名词命名，如Collectors 或者Collections 。接口的命名与类相似，例如Collection 或Comparator ，或者用一个以able 或ible结尾的形容同来命名，例如Runnable 、Iterable或者Accessible 。由于注解类型有这么多用处，因此没有单独安排词类。名词、动词、介词和形容词都很常用，例如BindingAnnotation 、Inject 、ImplementedBy 或者Singleton 。

  ​	执行某个动作的方法通常用动词或者动词短谓（包括对象）来命名，例如append或drawImage 。对于返回boolean值的方法，其名称往往以单词is开头，很少用has，后面跟名词或名词短话，或者任何具有形容词功能的单词或短语，例如isDigit 、isProbablePrime 、isEmpty 、isEnabled 或者hasSiblings 。

  ​	如果方法返回被调用对象的一个非boolean 的函数或者属性，它通常用名词、名词短语，或者以动词get 开头的动词短语来命名，例如size 、hashCode 或者getTime。有一个组织声称只有第三种形式（以get 开头）才可以接受，但是这种声明没有得到支持。前两种形式往往会产生可读性更好的代码，例如：

  ```java
  if(car.speed() > 2 * SPEED_LIMIT)
    generateAudibleAlert("Watch out for cops!");
  ```

  ​	以get开头的形式主要出现在被废弃的Java Beans规范中，它形成了早期的可重用组件架构的基础。有些现代工具继续依赖Beans命名惯例，你大可放心地在那些需要结合这些工具一起使用的代码中使用。如果类中包含了用于相同属性的setter方法和getter方法，强烈建议采用这种命名形式。在这种情况下，这两种方法应该分别被命名为getAttribute和setAttribute。

  ​	有些方法的名称值得专门提及。转换对象类型的实例方法，它们返回不同类型的独立对象的方法， 经常被称为toType ，例如toString或者toArray 。返回视图（view ，详见E6，视图的类型不同于接收对象的类型）的方法经常被称为asType，例如asList 。返回一个与被调用对象同值的基本类型的方法，经常被称为typeValue，例如intValue 。静态工厂的常用名称包括from、of、valueOf 、instance、getInstance、newInstance、getType和newType（E1） 。

  ​	域名称的语法惯例没有很好地建立起来，它们也没有类、接口和方法名称那么重要，因为设计良好的API很少会包含暴露出来的域。boolean类型的域命名与boolean类型的访问方法（accessor method）很类似，但是省去了初始的is，例如initialized和composite 。其他类型的域通常用名词或者名词短语来命名，比如height、digits或bodyStyle。局部变量的语法惯例类似于域的语法惯例，但是更弱一些。

  ​	总而言之，把标准的命名惯例当作一种内在的机制来看待，并且学着用它们作为第二特性。字面惯例是非常直接和明确的；语法惯例则更复杂，也更松散。下面这句话引自《The Java Language Specification》[JLS, 6.1］："如果长期养成的习惯用法与此不同，请不要盲目遵从这些命名惯例。"请使用大家公认的做法。

# 10、异常

​	充分发挥异常的优点，可以提高程序的可读性、可靠性和可维护性。如果使用不当，它们也会带来负面的影响。本章提供了一些关于有效使用异常的指导原则。

## * E69 只针对异常的情况才使用异常

+ 概述

  ​	某一天，如果你不走运的话，可能会碰到下面这样的代码：

  ```java
  // Horrible abuse of exceptions. Don't ever do this!
  try {
    int i = 0;
    while(true)
      range[i++].climb()
  } catch(ArrayIndexOutOfBoundsException e) {
  }
  ```

  ​	这段代码有什么作用？看起来根本不明显，这正是它没有真正被使用的原因（E67）。事实证明，作为一个要对数组元素进行遍历的实现方式，它的构想是非常拙劣的。当这个循环企图访问数组边界之外的第一个数组元素时，用抛出(throw)、捕获(catch)、忽略ArrayIndexOutOfBoundsException的手段来达到终止无限循环的目的。假定它与数组循环的标准模式是等价的，对于任何一个Java程序员来说，下面的标准模式一看就会明白：

  ```java
  for (Mountain m: range)
    m.climb();
  ```

  ​	那么，为什么有人会优先使用基于异常的循环，而不是用行之有效的模式呢?这是被误导了，他们企图利用Java的错误判断机制来提高性能，因为VM对每次数组访问都要检査越界情况，所以他们认为正常的循环终止测试被编译器隐藏了，但在for-each循环中仍然可见，这无疑是多余的，应该避免。这种想法有三个错误:

  + 因为异常机制的设计初衷是用于不正常的情形，所以几乎没有JVM实现试图对它们进行优化，使它们与显式的测试一样快速。
  + <u>把代码放在try-catch块中反而阻止了现代JVM实现本来可能要执行的某些特定优化</u>。
  + 对数组进行遍历的标准模式并不会导致冗余的检查。有些现代的JVM实现会将它们优化掉。

  ​	实际上，基于异常的模式比标准模式要慢得多。在作者的机器上，对于一个有100个元素的数组，基于标准模式比异常的模式快了2倍。

  ​	基于异常的循环模式不仅模糊了代码的意图，降低了它的性能，而且它还不能保证正常工作!如果出现了不相关的Bug，这个模式会悄悄地失效，从而掩盖了这个Bug，极大地增加了调试过程的复杂性。假设循环体中的计算过程调用了一个方法，这个方法执行了对某个不相关数组的越界访问。如果使用合理的循环模式，这个Bug会产生未被捕捉的异常，从而导致线程立即结東，产生完整的堆栈轨迹。如果使用这个被误导的基于异常的循环模式，与这个Bug相关的异常将会被捕捉到，并且被错误地解释为正常的循环终止条件。

  ​	这个例子的教训很简单：顾名思义，**异常应该只用于异常的情况下；它们永远不应该用于正常的控制流**。

  ​	<u>一般地，应该优先使用标准的、容易理解的模式，而不是那些声称可以提供更好性能的、弄巧成拙的方法</u>。即使真的能够改进性能，面对平台实现的不断改进，这种模式的性能优势也不可能一直保持。然而，由这种过度聪明的模式带来的微妙的Bug，以及维护的痛苦却依然存在。

  ​	这条原则对于API设计也有启发。**<u>设计良好的API不应该强迫它的客户端为了正常的控制流而使用异常</u>**。

  ​	<u>如果类具有“状态相关”(state- dependent)的方法，即只有在特定的不可预知的条件下才可以被调用的方法，这个类往往也应该有个单独的“状态测试”(state-testing)方法，即指示是否可以调用这个状态相关的方法</u>。例如， Iterator接口有一个“状态相关”的next方法，及相应的状态测试方法 hasNext。这使得利用传统的for循环(以及for-each循环，在内部使用了 hasNext方法)对集合进行迭代的标准模式成为可能：

  ```java
  for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
    Foo foo = i.next();
    ...
  }
  ```

  ​	如果Iterator缺少hasNext方法，客户端将被迫改用下面的做法：

  ```java
  // Do not use this hideous code for iteration over a collection!
  try {
    Iterator<Foo> i = collection.iterator();
    while(true) {
      Foo foo = i.next();
      ...
    }
  } catch (NoSuchElementException e) {
  }
  ```

  ​	这应该非常类似于本条目刚开始时对数组进行迭代的例子。除了代码烦琐且令人误解之外，这个基于异常的模式可能执行起来也比标准模式更差，并且还可能掩盖系统中其他不相关部分中的Bug。

  ​	<u>另一种提供单独的状态测试方法的做法是，如果“状态相关的”方法无法执行想要的计算，就让它返回一个零长度的 optional值（E55），或者返回一个可识别的值，比如null</u>。

  ​	对于**“状态测试方法”和“optional返回值或可识别的返回值”**这两种做法，有些指导原则可以帮助你在两者之中做出选择。

  + <u>如果对象将在缺少外部同步的情况下**被并发访问**，或者**可被外界改变状态**，就必须使用 optional返回值或者可识别的返回值，因为在调用“状态测试”方法和调用对应的“状态相关”方法的时间间隔之中，对象的状态有可能会发生变化</u>。
  + <u>如果单独的“状态测试”方法必须重复“状态相关”方法的工作，从性能的角度考虑，就应该使用可被识别的返回值</u>。
  + <u>如果所有其他方面都是等同的，那么“状态测试”方法则略优于可被识别的返回值</u>。它提供了稍微更好的可读性，对于使用不当的情形可能更加易于检测和改正：如果忘了去调用状态测试方法，状态相关的方法就会抛出异常，使这个Bug变得很明显；如果忘了去检查可识别的返回值，这个Bug就很难被发现。 <u>optional返回值不会有这方面的问题</u>。

---

+ 小结

  ​	总而言之，**异常是为了在异常情况下使用而设计的。不要将它们用于普通的控制流，也不要编写迫使它们这么做的API**。

## * E70 对可恢复的情况使用受检异常，对编程错误使用运行时异常

+ 概述

  ​	Java程序设计语言提供了三种可抛出结构(throwable)：

  + 受检异常(checked exception）
  + 运行时异常(run- time exception)
  + 错误(error)

  ​	关于什么时候适合使用哪种可抛出结构，程序员中间存在一些困惑。虽然这项决定并不总是那么清晰，但还是有些一般性的原则提出了强有力的指导。

  ​	<u>在决定使用受检异常或是未受检异常时，主要的原则是：**如果期望调用者能够适当地恢复，对于这种情况就应该使用受检异常**。通过抛出受检的异常，强迫调用者在一个 catch子句中处理该异常，或者将它传播出去。因此，方法中声明要抛出的每个受检异常，都是对API用户的一种潜在指示：与异常相关联的条件是调用这个方法的一种可能的结果</u>。

  ​	API的设计者让API用户面对受检异常，以此强制用户从这个异常条件中恢复。用户可以忽视这样的强制要求，只需捕获异常并忽略即可，但这往往不是个好办法（E77）。

  ​	有两种未受检的可抛出结构：运行时异常和错误。

  ​	在行为上两者是等同的：它们都是不需要也不应该被捕获的可抛出结构。

  ​	如果程序抛出未受检的异常或者错误，往往就属于不可恢复的情形，继续执行下去有害无益。如果程序没有捕捉到这样的可抛出结构，将会导致当前线程中断(halt)，并出现适当的错误消息。

  ​	**用运行时异常来表明编程错误**。大多数的运行时异常都表示前提违例(precondition violation)。所谓前提违例是指API的客户没有遵守API规范建立的约定。例如，数组访问的约定指明了数组的下标值必须在零和数组长度减1之间。 ArrayIndexOutOfBoundsException表明违反了这个前提。

  ​	这条建议有一个问题：<u>对于要处理可恢复的条件，还是处理编程错误，情况并非总是那么黑白分明</u>。

  ​	例如，<u>考虑资源枯竭的情形，这可能是由于程序错误而引起的，比如分配了块不合理的过大的数组，也可能确实是由于资源不足而引起的</u>。

  ​	如果资源枯竭是由于临时的短缺，或是临时需求太大所造成的，这种情况可能就是可恢复的。API设计者需要判断这样的资源枯竭是否允许恢复。

  + 如果你相信一种情况可能允许恢复，就使用受检的异常；
  + 如果不是，则使用运行时异常。<u>如果不清楚是否有可能恢复，最好使用未受检的异常</u>，原因请参见（E71）的讨论。

  ​	<u>虽然JLS(Java语言规范)并没有要求，但是按照惯例，错误往往被JVM保留下来使用，以表明资源不足、约束失败，或者其他使程序无法继续执行的条件。由于这已经是个几乎被普遍接受的惯例，因此最好不要再实现任何新的 Error子类</u>。

  + **<u>因此，你实现的所有未受检的抛出结构都应该是RuntimeException的子类(直接的或者间接的)</u>**。
  + **不仅不应该定义Error子类，甚至也不应该抛出AssertionError异常**。

  ​	<u>要想定义一个抛出结构，使它不是 Exception、 RuntimeException或 Error的子类，这也是可能的。JLS并没有直接规定这样的抛出结构，而是隐式地指定了：从行为意义上讲，它们等同于普通的受检异常(即 Exception的子类，但不是 RuntimeException的子类)。那么，什么时候应该使用这样的抛出结构呢？一句话：**永远也不会用到**。**它与普通的受检异常相比没有任何益处，只会困扰API的用户**</u>。

  ​	API的设计者往往会忘记，异常也是个完全意义上的对象，可以在它上面定义任意的方法。这些方法的主要用途是为捕获异常的代码而提供额外的信息，特别是关于引发这个异常条件的信息。如果没有这样的方法，程序员必须要懂得如何解析“该异常的字符串表示法”，以便获得这些额外信息。这是极为不好的做法（E12）。类很少会指定它们的字符串表示法中的细节，因此，对于不同的实现及不同的版本，字符串表示法会大相径庭。由此可见，<u>“解析异常的字符串表示法”的代码可能是不可移植的，也是非常脆弱的</u>。

  ​	因为受检异常往往指明了可恢复的条件，所以，对于这样的异常，提供一些辅助方法尤其重要，通过这些方法，调用者可以获得一些有助于恢复的信息。例如，假设因为用户资金不足，当他企图购买一张礼品卡时导致失败，于是抛出一个受检的异常。这个异常应该提供一个访问方法，以便允许客户查询所缺的费用金额，使得调用者可以将这个数值传递给用户。关于这个主题的更多详情，请参阅（E75）。

---

+ 小结

  + 对于可恢复的情况，要抛出受检异常；
  + 对于程序错误，要抛出运行时异常。
  + 不确定是否可恢复，则抛出未受检异常。

  + **不要定义任何既不是受检异常也不是运行时异常的抛出类型**。
  + 要在受检异常上提供方法，以便协助恢复。

> [Java中的异常处理2_受检异常与非受检异常 - 羊37 - 博客园 (cnblogs.com)](https://www.cnblogs.com/yang37/p/13994606.html)

## * E71 避免不必要地使用受检异常

+ 概述

  ​	许多Java程序员不喜欢受检异常，但是如果使用得当，它们可以改善API和程序。

  ​	**不同于返回码和未受检异常的是，它们强迫程序员处理异常的条件，大大增强了可靠性**。<u>也就是说，过分使用受检异常会使API使用起来非常不方便。如果方法抛出受检异常，调用该方法的代码就必须在一个或者多个 catch块中处理这些异常，或者它必须声明抛出这些异常，并让它们传播出去。无论使用哪一种方法，都给程序员增添了不可忽视的负担</u>。这种负担在Java8中更重了，因为抛出受检异常的方法不能直接在Stream中使用(详见E45至E48)。

  ​	如果正确地使用API并不能阻止这种异常条件的产生，并且一旦产生异常，使用API的程序员可以立即采取有用的动作，这种负担就被认为是正当的。除非这两个条件都成立否则更适合于使用未受检异常。作为一个石蕊测试(石蕊测试是指简单而具有决定性的测试)，你可以试着问自己：程序员将如何处理该异常。下面的做法是最好的吗?

  ```java
  } catch (TheCheckedException e) {
    throw new AssertionError(); // Can't happen!
  }
  ```

  ​	下面这种做法又如何？

  ```java
  } catch (TheCheckedException e) {
    e.printStackTrace(); // Oh well, we lose.
    System.exit(1);
  }
  ```

  ​	<u>如果使用API的程序员无法做得比这更好，那么未受检的异常可能更为合适</u>。

  ​	**如果方法抛出的受检异常是唯一的，它给程序员带来的额外负担就会非常高**。

  ​	<u>如果这个方法还有其他的受检异常，该方法被调用的时候，必须已经出现在一个try块中，所以这个异常只需要另外一个 catch块。如果方法只抛出一个受检异常，单独这一个异常就表示：该方法必须放置于一个try块中，并且不能在 Stream中直接使用</u>。在这种情况下，应该问问自己，是否还有别的途径可以避免使用受检异常。

  ​	**消除受检异常最容易的方法是，返回所要的结果类型的一个optional（E55）。这个方法不抛出受检异常，而只是返回一个零长度的optional**。<u>这种方法的缺点是，方法无法返回任何额外的信息，来详细说明它无法执行你想要的计算。相反，异常则具有描述性的类型，并且能够导出方法，以提供额外的信息（E70）</u>。

  ​	**“把受检异常变成未受检异常”的一种方法是，把这个抛出异常的方法分成两个方法，其中第一个方法返回一个 boolean值，表明是否应该抛出异常**。这种API重构，把下面的调用序列：

  ```java
  // Invocation with checked exception
  try {
    obj.action(args);
  } catch (TheCheckedException e) {
    ... // Handle exceptional condition
  }
  ```

  ​	重构为：

  ```java
  // Invocation with state-testing method and unchecked exception
  if (obj.actionPermitted(args)) {
    obj.action(args);
  } else {
    ... // Handle exceptional condition
  }
  ```

  ​	这种重构并非总是恰当的，但是，凡是在恰当的地方，它都会使API用起来更加舒服。虽然后者的调用序列没有前者漂亮，但是这样得到的API更加灵活。<u>如果程序员知道调用将会成功，或者不介意由于调用失败而导致的线程终止</u>，这种重构还允许以下这个更为简单的调用形式：

  ```java
  obj.action(args);
  ```

  ​	<u>如果你怀疑这个简单的调用序列是否符合要求，这个API重构可能就是恰当的。这样重构之后的API在本质上等同于（E69）中的“状态测试方法”，并且同样的告诫依然适用：如果对象将在缺少外部同步的情况下被并发访问，或者可被外界改变状态，这种重构就是不恰当的，因为在actionPermitted和action这两个调用的时间间隔之中，对象的状态有可能会发生变化。如果单独的actionPermitted方法必须重复action方法的工作，出于性能的考虑，这种API重构就不值得去做</u>。

---

+ 小结

  ​	总而言之，**在谨慎使用的前提之下，受检异常可以提升程序的可读性；如果过度使用，将会使API使用起来非常痛苦**。

  + **如果调用者无法恢复失败，就应该抛出未受检异常**。
  + <u>**如果可以恢复，并且想要迫使调用者处理异常的条件**，首选应该返回一个optional值</u>。
  + **<u>当且仅当万一失败时，这些无法提供足够的信息，才应该抛出受检异常</u>**。

## * E72 优先使用标准的异常

+ 概述

  ​	**专家级程序员与缺乏经验的程序员一个最主要的区别在于，专家追求并且通常也能够实现高度的代码重用**。<u>代码重用是值得提倡的，这是一条通用的规则，异常也不例外。Java平台类库提供了一组基本的未受检异常，它们满足了绝大多数API的异常抛出需求</u>。

  ​	重用标准的异常有多个好处。

  + 其中最主要的好处是，它使API更易于学习和使用，因为它与程序员已经熟悉的习惯用法一致。
  + 第二个好处是，对于用到这些API的程序而言，它们的可读性会更好，因为它们不会出现很多程序员不熟悉的异常。
  + 最后(也是最不重要的)一点是，异常类越少，意味着内存占用(footprint)就越小，装载这些类的时间开销也越少。

  ​	**最经常被重用的异常类型是IllegalArgumentException（E49）**。

  ​		<u>当调用者传递的参数值不合适的时候，往往就会抛出这个异常</u>。比如，假设某一个参数代表了"某个动作的重复次数"，如果程序员给这个参数传递了一个负数，就会抛出这个异常。

  ​	**另一个经常被重用的异常是IllegalStateException**。

  ​		<u>如果因为接收对象的状态而使调用非法，通常就会抛出这个异常</u>。例如，如果在某个对象被正确地初始化之前，调用者就企图使用这个对象，就会抛出这个异常。

  ​	**可以这么说，所有错误的方法调用都可以被归结为<u>非法参数</u>或者<u>非法状态</u>，但是，还有一些其他的标准异常也被用于某些特定情况下的非法参数和非法状态**。

  + 如果调用者在某个不允许null值的参数中传递了null，习惯的做法就是抛出NullPointerException异常，而不是IllegalArgumentException。
  + 同样地，如果调用者在表示序列下标的参数中传递了越界的值，应该抛出的就是IndexOutOfBoundsException异常，而不是IllegalArgumentException。

  ​	**另一个值得了解的通用异常是ConcurrentModificationException**。

  ​		<u>如果检测到一个专门设计用于单线程的对象，或者与外部同步机制配合使用的对象正在(或已经)被并发地修改，就应该抛出这个异常。这个异常顶多就是一个提示，因为不可能可靠地侦测到并发的修改</u>。

  ​	**最后一个值得注意的标准异常是 UnsupportedOperationException。如果对象不支持所请求的操作，就会抛出这个异常**。

  ​		很少用到它，因为绝大多数对象都会支持它们实现的所有方法。<u>如果类没有实现由它们实现的接口所定义的一个或者多个可选操作(optional operation)，它就可以使用这个异常</u>。例如，对于只支持追加操作的List实现，如果有人试图从列表中删除元素，它就会抛出这个异常。

  ​	<u>**不要直接重用 Exception、 RuntimeException、 Throwable或者 Error**。对待这些类要像对待抽象类一样。你无法可靠地测试这些异常，因为它们是一个方法可能抛出的其他异常的超类</u>。

  ​	下表概括了最常见的可重用异常:

  | 异常                            | 使用场合                                     |
  | ------------------------------- | -------------------------------------------- |
  | IllegalArgumentException        | **非null**的参数值不正确                     |
  | IllegalStateException           | 不适合方法调用的对象状态                     |
  | NullPointerException            | 在禁止使用null的情况下参数值为null           |
  | IndexOutOfBoundsException       | 下标参数值越界                               |
  | ConcurrentModificationException | 在禁止并发修改的情况下，监测到对象的并发修改 |
  | UnsupportedOperationException   | **对象不支持用户请求的方法**                 |

  ​	虽然这些都是Java平台类库中迄今为止最常被重用的异常，但是，在条件许可的情况下，其他的异常也可以被重用。例如，如果要实现诸如复数或者有理数之类的算术对象，也可以重用 ArithmeticException和 NumberFormatException。

  ​	<u>如果某个异常能够满足你的需要，就不要犹豫，使用就是，不过一定要确保抛出异常的条件与该异常的文档中描述的条件一致</u>。这种重用必须建立在语义的基础上，而不是建立在名称的基础之上。

  ​	而且，如果希望稍微增加更多的失败-捕获(failure- capture)信息（E75），可以放心地子类化标准异常，但**<u>要记住异常是可序列化的(详见第12章)。这也正是“如果没有非常正当的理由，千万不要自己编写异常类”的原因</u>**。

---

+ 小结

  ​	选择重用哪一种异常并非总是那么精确，因为上表中的“使用场合”并不是相互排斥的。

  ​	比如，以表示一副纸牌的对象为例。假设有一个处理发牌操作的方法，它的参数是发手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副纸牌的剩余张数。<u>这种情形既可以被解释为IllegalArgumentException(handSize参数的值太大)，也可以被解释为IllegalStateException(纸牌对象包含的纸牌太少)。在这种情况下，**如果没有可用的参数值，就抛出IllegalStateException，否则就抛出IllegalArgumentException**</u>。

## E73 抛出与抽象对应的异常

